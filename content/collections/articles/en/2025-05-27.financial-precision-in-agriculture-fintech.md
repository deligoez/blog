---
id: 07b11a80-824a-42ce-a84d-8b5fcad94cc4
blueprint: articles
title: 'Financial Precision in Agriculture Fintech'
subtitle: 'Our Journey from 2 to 16 Decimal Places'
updated_by: b8f3533e-0fcf-42b9-a3d8-c8691deaf917
updated_at: 1765921252
content:
  -
    type: paragraph
    content:
      -
        type: text
        text: 'At '
      -
        type: text
        marks:
          -
            type: link
            attrs:
              href: 'https://www.tarfin.com/'
              rel: 'noopener nofollow'
              target: _blank
              title: null
        text: Tarfin
      -
        type: text
        text: ", Europe's leading fintech platform for farmer agri-input financing, thousands of farmers have chosen us to purchase their seeds, fertilizers, feed and equipment with flexible payment terms. Founded in 2017 in Turkey, we help farmers across 75+ cities by letting them compare prices from 1200+ retailers and purchase agri-inputs without tying up their cash. Since 2021, we've expanded to Romania, bringing the same farmer-friendly financing model to help small and medium-sized farmers access agricultural inputs without guarantees or hidden costs."
  -
    type: paragraph
    content:
      -
        type: text
        text: "When we started building our system, we followed the best practices known at the time: storing monetary values as integers in the database to avoid floating-point rounding issues. However, as our business grew and became more sophisticated, we discovered that even this approach wasn't sufficient. This article shares our journey of migrating from 2 decimal precision to a "
      -
        type: text
        marks:
          -
            type: code
        text: 'DECIMAL(29,16)'
      -
        type: text
        text: " structure in our database - that's 13 digits before the decimal point and 16 after."
  -
    type: paragraph
    content:
      -
        type: text
        text: 'After experiencing the limitations of integer storage, we adopted the '
      -
        type: text
        marks:
          -
            type: link
            attrs:
              href: 'https://github.com/brick/money'
              rel: 'noopener nofollow'
              target: _blank
              title: null
        text: Brick/Money
      -
        type: hardBreak
      -
        type: text
        text: 'library for all monetary operations in our Laravel application:'
  -
    type: heading
    attrs:
      level: 1
    content:
      -
        type: text
        text: 'The Foundation: Brick/Money Library'
  -
    type: set
    attrs:
      id: mj926som
      values:
        type: code
        code: |-
          ```php
          use Brick\Math\RoundingMode;  
          use Brick\Money\Money;  
          use Brick\Money\Context\CustomContext;  
            
          // Before: 2 decimal precision  
          $context2 = new CustomContext(2);  
          $price = Money::of(999.99, "USD", $context2);  
          $commission = $price->multipliedBy("0.025", RoundingMode::HALF_UP); // 25 USD  
            
          // After: 16 decimal precision  
          $context16 = new CustomContext(16);  
          $price = Money::of("999.9999999999999", "USD", $context16);  
          $commission = $price->multipliedBy("0.025", RoundingMode::HALF_UP); // 24.9999999999999975 USD  
          ```
  -
    type: heading
    attrs:
      level: 1
    content:
      -
        type: text
        text: 'Our Starting Point: Integer Storage'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'When we started building Tarfin, we knew about the dangers of floating-point arithmetic. The classic example every developer learns:'
  -
    type: set
    attrs:
      id: mj927pv2
      values:
        type: code
        code: |-
          ```php
          // The famous floating-point precision problem  
          $a = 0.1;  
          $b = 0.2;  
          $sum = $a + $b;  
            
          var_dump($sum === 0.3); // bool(false)!  
          printf("%.17f", $sum);  // 0.30000000000000004  

          ```
  -
    type: paragraph
    content:
      -
        type: text
        text: 'This happens because computers store floating-point numbers in binary (base 2), and many decimal fractions cannot be represented exactly in binary. Just like 1/3 cannot be precisely represented in decimal (0.333...), 0.1 cannot be precisely represented in binary.'
  -
    type: paragraph
    content:
      -
        type: text
        text: "That's why we followed the best practice of storing monetary values as integers:"
  -
    type: set
    attrs:
      id: mj928tpb
      values:
        type: code
        code: |-
          ```php
          // Instead of storing 100.50 USD as float  
          $price = 100.50; // Dangerous!  
            
          // We stored it as integer cents  
          $priceInCents = 10050; // Safe from floating-point errors  
          ```
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The integer storage approach had several advantages:'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Exact Representation'
  -
    type: set
    attrs:
      id: mj929ewi
      values:
        type: code
        code: |-
          ```php
          // Float storage problems  
          $dbPrice = 19.99;  
          $quantity = 3;  
          $total = $dbPrice * $quantity; // 59.97... or is it?  
          printf("%.17f", $total); // 59.96999999999999886  
            
          // Integer storage (cents)  
          $dbPriceCents = 1999;  
          $quantity = 3;  
          $totalCents = $dbPriceCents * $quantity; // Exactly 5997  
          $totalUSD = $totalCents / 100; // 59.97  
          ```
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Consistent Database Operations'
  -
    type: set
    attrs:
      id: code-sql-comparison
      values:
        type: code
        code: |-
          ```sql
          -- Float columns can have comparison issues
          SELECT *
          FROM orders
          WHERE total = 59.97;
          -- Might miss rows!

          -- Integer columns are reliable
          SELECT *
          FROM orders
          WHERE total_cents = 5997; -- Always works
          ```
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'No Accumulating Errors'
  -
    type: set
    attrs:
      id: code-no-accum
      values:
        type: code
        code: |-
          ```php
          // Float accumulation problem
          $balance = 0.0;
          for ($i = 0; $i < 10000; $i++) {
              $balance += 0.01;}
          echo $balance; // 100.00000000001 (should be 100.00)
                         // Note: exact error may vary by system/PHP version

          // Integer accumulation is perfect
          $balanceCents = 0;
          for ($i = 0; $i < 10000; $i++) {
              $balanceCents += 1;}
          echo $balanceCents / 100; // Exactly 100.00
          ```
  -
    type: paragraph
    content:
      -
        type: text
        text: 'This integer approach worked well for amounts with 2 decimal places, but our business requirements soon exceeded these limitations.'
  -
    type: heading
    attrs:
      level: 1
    content:
      -
        type: text
        text: "Why 2 Decimal Places Weren't Enough"
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Income Protected Sales (IPS)'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Our Income Protected Sales (IPS) model - what we call "'
      -
        type: text
        marks:
          -
            type: italic
        text: 'Gelir KorumalÄ± SatÄ±ÅŸ'
      -
        type: text
        text: '" in Turkish - is essentially a commodity price hedging mechanism for farmers. In this payment system, farmers can choose to pay based on the average commodity prices at their selected payment date, rather than the purchase date. This protects them from price volatility in agricultural markets.'
  -
    type: paragraph
    content:
      -
        type: text
        text: "For example, a farmer buying fertilizer in March can choose to pay in October based on October's wheat prices. If wheat prices rise, they pay less; if prices fall, they're protected by minimum price guarantees. This hedging mechanism requires extreme precision in calculations:"
  -
    type: set
    attrs:
      id: code-ips-example
      values:
        type: code
        code: |-
          ```php
          // Example: 1000 USD sale equals 100kg of wheat
          $cashPrice = '1000.00';
          $wheatAmount = '100.1234567890123456'; // kg
          $wheatPrice = '9.876543210987654321'; // USD/kg

          // With 2 decimals:
          $result = round(100.12 * 9.88, 2); // 989.19 USD

          // Actual value:
          $result = '989.1851851851851851...'; // Significant difference!
          ```
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'VAT Calculations on Small Unit Price Products'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Seeds and similar agricultural inputs often have very small unit prices but are purchased in large quantities. This is where VAT (KDV in Turkish) calculation precision becomes critical:'
  -
    type: set
    attrs:
      id: code-vat-example
      values:
        type: code
        code: |-
          ```php
          // Example: Seed with small unit price
          $unitPrice = '0.05'; // 0.05 USD per seed
          $quantity = 100000; // Farmer buys 100,000 seeds
          $vatRate = 8; // 8% VAT

          // With 2 decimal precision:
          $unitPriceWithoutVat = round(0.05 / 1.08, 2); // 0.05 USD (wrong!)
          $vatAmount = 0.00; // No VAT calculated!

          // With 16 decimal precision:
          $unitPriceWithoutVat = '0.0462962962962963'; // Correct
          $vatAmount = '0.0037037037037037'; // Correct VAT

          // For 100,000 seeds:
          // 2 decimals: 0 USD VAT loss
          // 16 decimals: 370.37 USD VAT correctly calculated
          ```
  -
    type: paragraph
    content:
      -
        type: text
        text: 'When farmers purchase tens or hundreds of thousands of these small-unit items, rounding errors compound into significant amounts.'
  -
    type: heading
    attrs:
      level: 1
    content:
      -
        type: text
        text: 'Float vs String: The IEEE-754 Problem'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'What is IEEE-754?'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'IEEE-754 is the standard for floating-point arithmetic used by virtually all modern computers. It represents numbers in binary (base 2) using three components:'
  -
    type: bulletList
    content:
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Sign bit'
              -
                type: text
                text: ': Positive or negative'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: Exponent
              -
                type: text
                text: ': The magnitude of the number'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Mantissa (fraction)'
              -
                type: text
                text: ': The precision bits'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The problem is that many decimal fractions cannot be exactly represented in binary. Just as 1/3 becomes 0.333... (infinite) in decimal, numbers like 0.1 become infinite in binary:'
  -
    type: set
    attrs:
      id: code-binary-representation
      values:
        type: code
        code: |-
          ```sh
          0.1 in decimal = 0.00011001100110011... in binary (repeating forever)
          ```
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Since computers have finite memory, they must truncate this infinite representation, leading to rounding errors.'
  -
    type: set
    attrs:
      id: mj93c0yt
      values:
        type: image
        image: articles/financial-precision-in-agriculture-fintech/ieee-754.svg
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'The Mental Shift: From Float to String'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Moving from writing '
      -
        type: text
        marks:
          -
            type: code
        text: '$amount = 1234.567'
      -
        type: text
        text: ' to '
      -
        type: text
        marks:
          -
            type: code
        text: "$amount = '999999.9999999999999999'"
      -
        type: text
        text: ' requires a fundamental mental shift for developers. It feels unnatural at first to treat numbers as strings, but this becomes inevitable when working with high-precision financial calculations - these precise decimal values simply cannot fit within the IEEE-754 standard without loss of precision.'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Real Examples from Our System'
  -
    type: paragraph
    content:
      -
        type: text
        text: "Here's something that surprised us: Laravel returns DECIMAL database values as strings, not floats. At first, this seemed odd - why would a numeric database type come back as a string? The answer reveals a deeper truth about precision."
  -
    type: paragraph
    content:
      -
        type: text
        text: "PDO (PHP's database layer) returns DECIMAL values as strings because PHP's float type cannot accurately represent many decimal values. By returning strings, it preserves the exact precision stored in your database. The danger comes when developers, not understanding this protection, convert these strings to floats:"
  -
    type: set
    attrs:
      id: code-pdo-precision
      values:
        type: code
        code: |-
          ```php
          use Brick\Money\Context\CustomContext;
          use Brick\Money\Money;

          $context = new CustomContext(16);

          // PDO correctly returns DECIMAL as string to preserve precision
          $dbAmount = "999999.9999999999999999"; // From DECIMAL(29,16) column

          // String preserves exact value
          $moneyStr = Money::of($dbAmount, "USD", $context);
          // Money amount: 999999.9999999999999999

          // Developer "helps" by converting to float - DESTROYS precision!
          $moneyFloat = Money::of((float) $dbAmount, "USD", $context);
          // Money amount: 1000000

          // That's a 0.0000000000000001 USD difference that became 1 cent!
          ```
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The real danger comes from compounding errors in chained operations:'
  -
    type: set
    attrs:
      id: code-chained-operations
      values:
        type: code
        code: |-
          ```php
          // Chained operations with 16 decimal precision
          $dbPrice = '99999.1234567890123456';
          $dbDiscount = '0.1234567890123456';    // ~12.35% discount
          $dbTax = '0.2000000000000001';         // 20% VAT
          $dbCommission = '0.0123456789012345';   // Platform commission

          // String approach: preserves all precision
          // Float approach: compounds errors at each step
          // Difference after 4 operations: 0.0000000006 USD

          // Imagine processing thousands of transactions daily!
          ```
  -
    type: heading
    attrs:
      level: 1
    content:
      -
        type: text
        text: 'Performance Considerations'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'You might worry about performance when using strings instead of floats. In our experience:'
  -
    type: bulletList
    content:
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'The performance difference is negligible for most operations'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'The accuracy gained far outweighs any minimal performance cost'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'Database indexes work perfectly with '
              -
                type: text
                marks:
                  -
                    type: code
                text: 'DECIMAL(29,16)'
              -
                type: text
                text: ' columns'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'Modern databases are optimized for decimal arithmetic'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'However, there are trade-offs to consider:'
  -
    type: bulletList
    content:
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: Storage
              -
                type: text
                text: ': Higher precision means more storage space. '
              -
                type: text
                marks:
                  -
                    type: code
                text: 'DECIMAL(29,16)'
              -
                type: text
                text: ' uses more bytes than '
              -
                type: text
                marks:
                  -
                    type: code
                text: 'DECIMAL(10,2)'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Bulk Operations'
              -
                type: text
                text: ': When processing hundreds or thousands of calculations, string-based arithmetic is slower than'
              -
                type: hardBreak
              -
                type: text
                text: 'native float operations'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'The Right Balance'
              -
                type: text
                text: ': '
              -
                type: text
                marks:
                  -
                    type: code
                text: 'DECIMAL(29,16)'
              -
                type: text
                text: ' was our sweet spot, but your application might need different precision based on'
              -
                type: hardBreak
              -
                type: text
                text: 'your specific requirements'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The Brick/Money library mitigates performance impacts by using optimized arbitrary-precision arithmetic libraries like '
      -
        type: text
        marks:
          -
            type: code
        text: BCMath
      -
        type: text
        text: ' or '
      -
        type: text
        marks:
          -
            type: code
        text: GMP
      -
        type: text
        text: ' under the hood. These extensions are specifically designed for high-precision calculations and offer the best balance between accuracy and performance for financial applications.'
  -
    type: heading
    attrs:
      level: 1
    content:
      -
        type: text
        text: 'Laravel Implementation Best Practices'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Model Casting'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Our journey with Laravel model casting evolved through several stages, following our database evolution:'
  -
    type: set
    attrs:
      id: code-stage0-integer
      values:
        type: code
        code: |-
          ```php
          // Stage 0: INTEGER storage (cents) ðŸ’°
          // Database: amount BIGINT (stored as cents)
          protected $casts = [
              'amount' => 'integer',  // 10050 cents = 100.50 USD
          ];
          ```
  -
    type: paragraph
    content:
      -
        type: text
        text: 'When we started, we stored monetary values as integers in cents. This worked well for avoiding floating-point issues, but limited us to 2 decimal precision.'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'After migrating to '
      -
        type: text
        marks:
          -
            type: code
        text: DECIMAL
      -
        type: text
        text: ' storage, we discovered something crucial: MySQL returns '
      -
        type: text
        marks:
          -
            type: code
        text: DECIMAL
      -
        type: text
        text: ' values as strings to PHP, while '
      -
        type: text
        marks:
          -
            type: code
        text: FLOAT/DOUBLE
      -
        type: text
        text: ' columns return as numbers. This happens because '
      -
        type: text
        marks:
          -
            type: code
        text: DECIMAL
      -
        type: text
        text: " values can have precision that exceeds PHP's float capacity (~15 significant digits)."
  -
    type: set
    attrs:
      id: code-stage1-wrong
      values:
        type: code
        code: |-
          ```php
          // Stage 1: WRONG - Don't cast DECIMAL to float! âŒ
          protected $casts = [
              'amount' => 'float',  // This destroys precision!
          ];
          // Database value: '999.9999999999999999'
          // After float cast: 1000.0
          ```
  -
    type: paragraph
    content:
      -
        type: text
        text: "We never actually implemented Stage 1 in production, but it's a common mistake developers make when transitioning from integer to decimal storage."
  -
    type: set
    attrs:
      id: code-stage2-string
      values:
        type: code
        code: |-
          ```php
          // Stage 2: BETTER - Preserve string from database âœ…
          protected $casts = [
              'amount' => 'string',  // Keeps '999.9999999999999999' intact
          ];
          ```
  -
    type: paragraph
    content:
      -
        type: text
        text: 'This was our first working solution with '
      -
        type: text
        marks:
          -
            type: code
        text: DECIMAL
      -
        type: text
        text: ' columns. By keeping values as strings, we preserved all precision from the database. However, we still had to manually convert to Money objects everywhere.'
  -
    type: set
    attrs:
      id: code-stage3-money2
      values:
        type: code
        code: |-
          ```php
          // Stage 3: GOOD - Custom Money cast with 2 decimal precision âœ… âœ…
          protected $casts = [
              'amount' => MoneyCast::class . ':2',  // Auto-converts to Money object
          ];
          ```
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Creating a custom cast was a game-changer. Our '
      -
        type: text
        marks:
          -
            type: code
        text: MoneyCast
      -
        type: text
        text: ' automatically handled the conversion between '
      -
        type: text
        marks:
          -
            type: code
        text: DECIMAL
      -
        type: text
        text: ' database columns and Money objects.'
  -
    type: set
    attrs:
      id: code-stage4-money16
      values:
        type: code
        code: |-
          ```php
          // Stage 4: BEST - Custom Money cast with 16 decimal precision âœ…âœ…âœ…
          protected $casts = [
              'amount' => MoneyCast::class . ':16',  // Full precision Money objects
          ];

          // Full precision maintained throughout the stack
          $money = $model->amount; // Money object with 16 decimal precision
          $preciseCalculation = $money->multipliedBy('1.0000000000000001');
          ```
  -
    type: paragraph
    content:
      -
        type: text
        text: 'As we discovered edge cases with seeds, VAT calculations, and Income Protected Sales, we upgraded to 16 decimal precision. This custom cast automatically handles the conversion between our '
      -
        type: text
        marks:
          -
            type: code
        text: 'DECIMAL(29,16)'
      -
        type: text
        text: ' database column and Money objects, ensuring precision is maintained throughout the application lifecycle.'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Database-Level Precision Verification'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'When we chose '
      -
        type: text
        marks:
          -
            type: code
        text: 'DECIMAL(29,16)'
      -
        type: text
        text: ", we naturally expected MySQL to handle the precision correctly - after all, that's the whole point of the "
      -
        type: text
        marks:
          -
            type: code
        text: DECIMAL
      -
        type: text
        text: ' type. But given the critical nature of financial calculations, we decided to verify this assumption with comprehensive tests.'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Our curiosity paid off with reassuring results:'
  -
    type: set
    attrs:
      id: code-mysql-precision-test
      values:
        type: code
        code: |-
          ```sql
          -- Test: Can MySQL accurately sum 10 tiny values?
          -- 10 x 0.0000000000000001 should equal exactly 0.0000000000000010
          SELECT SUM(amount) = 0.0000000000000010 as is_exact
          FROM precision_test
          WHERE amount = 0.0000000000000001;
          -- Result: 1 (TRUE) âœ“

          -- Test: Can MySQL detect differences at the 16th decimal?
          SELECT amount,
                 amount = 100.0000000000000000 as equals_100
          FROM precision_test
          WHERE amount IN (100.0000000000000000, 100.0000000000000001);
          -- Results show it correctly distinguishes between the values âœ“
          ```
  -
    type: paragraph
    content:
      -
        type: text
        text: "These tests confirmed what we hoped: MySQL's "
      -
        type: text
        marks:
          -
            type: code
        text: DECIMAL
      -
        type: text
        text: " implementation is rock-solid. Aggregate functions preserve all decimal places, comparisons work at full precision, and there are no accumulation errors. This means database-level calculations (when needed for performance) won't compromise precision."
  -
    type: paragraph
    content:
      -
        type: text
        text: "However, this doesn't change our golden rule: always pass "
      -
        type: text
        marks:
          -
            type: code
        text: DECIMAL
      -
        type: text
        text: ' values as strings to PHP and use Money objects for application-level calculations. The database handles storage and basic operations perfectly, but complex business logic belongs in the application layer with proper money handling libraries.'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Database Migration'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'When we decided to move from integer to '
      -
        type: text
        marks:
          -
            type: code
        text: 'DECIMAL(29,16)'
      -
        type: text
        text: ', the migration process taught us valuable lessons:'
  -
    type: set
    attrs:
      id: code-migration-schema
      values:
        type: code
        code: |-
          ```php
          Schema::table('transactions', function (Blueprint $table) {
              // OLD: Stored as unsigned big integer (minor units)
              $table->unsignedBigInteger('amount'); // Stored in cents

              // NEW: 13 integer digits + 16 decimal places = 29 total precision
              $table->decimal('amount', 29, 16);
          });
          ```
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The actual migration required careful data conversion:'
  -
    type: set
    attrs:
      id: code-migration-up
      values:
        type: code
        code: |-
          ```php
          public function up()
          {
              // Step 1: Add temporary decimal column
              Schema::table('transactions', function (Blueprint $table) {
                  $table->decimal('amount_decimal', 29, 16)->nullable();
              });

              // Step 2: Convert cents to dollars (divide by 100!)
              DB::statement('UPDATE transactions SET amount_decimal = amount / 100');

              // Step 3: Swap columns
              Schema::table('transactions', function (Blueprint $table) {
                  $table->dropColumn('amount');
                  $table->renameColumn('amount_decimal', 'amount');
              });
          }
          ```
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Money Service Integration'
  -
    type: set
    attrs:
      id: code-money-service
      values:
        type: code
        code: |-
          ```php
          use Brick\Money\Context\CustomContext;
          use Brick\Money\Money;

          // Context with 16 decimal precision
          $context = new CustomContext(16);

          // With DECIMAL(29,16), we can store:
          // Max: 9,999,999,999,999.9999999999999999 USD (13 digits before, 16 after)
          // This is well within safe number ranges for both PHP and JavaScript

          // Always pass strings to Money::of()
          $money = Money::of($dbAmount, "USD", $context); // Precision preserved

          // DECIMAL(29,16) handles large amounts perfectly
          $largeAmount = "9999999999999.9999999999999999"; // Max for DECIMAL(29,16)
          $money = Money::of($largeAmount, "USD", $context); // Works perfectly
          ```
  -
    type: heading
    attrs:
      level: 1
    content:
      -
        type: text
        text: 'Common Pitfalls When Working with High Precision'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'After implementing '
      -
        type: text
        marks:
          -
            type: code
        text: 'DECIMAL(29,16)'
      -
        type: text
        text: ' and proper model casting, we discovered several non-obvious pitfalls in production:'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'External Data Sources'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The biggest challenges come from data entering your system:'
  -
    type: set
    attrs:
      id: code-external-data
      values:
        type: code
        code: |-
          ```php
          // âŒ WRONG: Trusting external number formats
          $csvImport = "1.234,56"; // European format from Excel
          $apiResponse = ["amount" => 1.0e-16]; // Scientific notation

          // âœ… CORRECT: Normalize before processing
          $normalized = str_replace(',', '.', str_replace('.', '', $csvImport)); // Remove thousands separator first
          $apiAmount = sprintf('%.16f', $apiResponse['amount']); // Convert scientific to decimal
          ```
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Money library will throw '
      -
        type: text
        marks:
          -
            type: code
        text: NumberFormatException
      -
        type: text
        text: ' for invalid formats, which is good - but it means you need robust input validation in your data pipelines.'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'JSON Encoding Concerns'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'When sending monetary values through APIs:'
  -
    type: set
    attrs:
      id: code-json-encoding
      values:
        type: code
        code: |-
          ```php
          use Brick\Money\Context\CustomContext;
          use Brick\Money\Money;

          $context = new CustomContext(16);

          // âŒ RISKY: Direct JSON encoding might use scientific notation
          $data = ["amount" => 0.0000000000000001];
          echo json_encode($data); // {"amount":1.0e-16} - Precision lost!

          // âœ… CORRECT: Always use strings
          $money = Money::of("0.0000000000000001", "USD", $context);
          $data = ["amount" => (string) $money->getAmount()]; // Cast to string
          echo json_encode($data); // {"amount":"0.0000000000000001"}

          // Also watch out for json_decode!
          $json = '{"price": 0.0000000000000001}';
          $decoded = json_decode($json, true); // $decoded['price'] is float!
          $decodedSafe = json_decode($json, true, 512, JSON_BIGINT_AS_STRING);
          ```
  -
    type: paragraph
    content:
      -
        type: text
        text: 'These real-world issues taught us that high precision requires vigilance not just in calculations, but throughout your entire data flow.'
  -
    type: heading
    attrs:
      level: 1
    content:
      -
        type: text
        text: 'Creative Solution: Automatic Discount Coupons for Rounding Differences'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'While we were working on our migration from 2 to 16 decimal precision - a significant infrastructure change that would take months to complete - we needed an immediate solution for the rounding differences that were causing daily headaches for our accounting team. Every invoice with a rounding discrepancy meant manual reconciliation work, explanations to farmers, and additional burden on our finance department.'
  -
    type: paragraph
    content:
      -
        type: text
        text: "This led us to develop what we initially thought of as a temporary workaround but turned out to be an ingenious approach that solved multiple problems at once. Rather than rushing the precision migration and risking errors, we could take our time to do it right while immediately eliminating the accounting team's reconciliation burden."
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The core challenge remained: while we perform all calculations using '
      -
        type: text
        marks:
          -
            type: code
        text: RationalMoney
      -
        type: text
        text: ' with infinite precision, our database and financial systems could only store prices with 2 decimal places (0.01 USD minimum). This creates an inevitable precision loss at the very last step - when we must convert our perfectly calculated rational numbers into storable decimal values.'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'The Mathematical Challenge'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Consider this scenario from our Income Protected Sales calculations:'
  -
    type: set
    attrs:
      id: code-math-challenge
      values:
        type: code
        code: |-
          ```php
          // Target total: 999.99 USD to be distributed across 3 items
          // Item ratios: 40%, 35%, 25%

          // Perfect rational calculation:
          Item 1: 399.996 USD â†’ rounds to 400.00 USD
          Item 2: 349.9965 USD â†’ rounds to 350.00 USD
          Item 3: 249.9975 USD â†’ rounds to 250.00 USD

          // Total after rounding: 1000.00 USD (0.01 USD over!)
          ```
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Even though we maintain perfect precision throughout all calculations using '
      -
        type: text
        marks:
          -
            type: code
        text: RationalMoney
      -
        type: text
        text: ', the final conversion to 2-decimal storage creates a 0.01 USD discrepancy. Across thousands of transactions, these penny differences could accumulate into significant amounts.'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Our Intelligent Solution'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Rather than accepting this precision loss or attempting to "fudge" the numbers, we developed an automated system that maintains both mathematical accuracy and accounting integrity. This solution immediately freed our accounting team from manual reconciliation work while we continued our careful migration to 16 decimal precision:'
  -
    type: set
    attrs:
      id: code-handle-rounding
      values:
        type: code
        code: |-
          ```php
          public function handleRoundingDifference(
              IPSPriceCalculationContext $context,
              int $allocatedTotal,
              int $targetTotal
          ): void {
              $difference = $allocatedTotal - $targetTotal;
              $threshold = config('tarfin.application.max_uncorrected_rounding_difference');

              if ($difference > $threshold) {
                  // Create automatic coupon for the exact difference
                  $coupon = Coupon::create([
                      'code' => 'ROUND-'.Str::random(8),
                      'description' => 'Rounding Difference - Automatically created',
                      'redemption_limit' => 1,
                  ]);

                  // Apply proportionally to maintain item ratios
                  $this->distributeCouponProportionally($coupon, $order, $difference);
              }
          }
          ```
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'How It Preserves Precision'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The key insight is that we perform all calculations at the '
      -
        type: text
        marks:
          -
            type: code
        text: RationalMoney
      -
        type: text
        text: ' level - with infinite precision - and only encounter rounding when converting to database storage:'
  -
    type: set
    attrs:
      id: code-calculate-item-prices
      values:
        type: code
        code: |-
          ```php
          private function calculateItemPrices(OrderItem $item, Money $allocatedAmount, RationalMoney $minimumUnitPrice): array
          {
              // Work with rational numbers for perfect precision
              $unitWithKdv = $allocatedAmount->toRational()->dividedBy($item->quantity);

              // All VAT calculations happen in rational space
              $prices = $this->calculatePriceComponents($unitWithKdv, $item->kdv);

              // Only at the very end do we convert to 2-decimal Money
              return [
                  'unit_w_kdv' => $unitWithKdv,  // Still RationalMoney
                  'total_w_kdv_minor' => $totalWithKdv->to(new CustomContext(2), RoundingMode::HALF_UP)
                                              ->getMinorAmount()->toInt()
              ];
          }
          ```
  -
    type: paragraph
    content:
      -
        type: text
        text: 'This approach ensures:'
  -
    type: orderedList
    attrs:
      start: 1
    content:
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Perfect calculation accuracy'
              -
                type: text
                text: ': All intermediate calculations use RationalMoney'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Transparent correction'
              -
                type: text
                text: ': Any rounding difference is explicitly recorded as a discount'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Proportional distribution'
              -
                type: text
                text: ': The discount is distributed maintaining the original price ratios'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Complete auditability'
              -
                type: text
                text: ': Every penny is accounted for in the system'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Real-World Example'
  -
    type: paragraph
    content:
      -
        type: text
        text: "From our test suite, here's how it works in practice:"
  -
    type: set
    attrs:
      id: code-real-world-example
      values:
        type: code
        code: |-
          ```php
          // Order with calculated forward price: 10,000.00 USD
          // After allocation and rounding: 10,001.00 USD
          // Difference: 1.00 USD

          // System automatically:
          // 1. Creates coupon ROUND-X8K2M9P1 for 1.00 USD
          // 2. Distributes proportionally:
          //    - Item 1 (60% of order): 0.60 USD discount
          //    - Item 2 (40% of order): 0.40 USD discount
          // 3. Final totals match exactly: 10,000.00 USD
          ```
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Handling Edge Cases with Minimum Constraints'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The solution becomes even more sophisticated when dealing with minimum price constraints. Each price component (unit price, VAT amount) must be at least 0.01 USD:'
  -
    type: set
    attrs:
      id: code-ensure-minimum
      values:
        type: code
        code: |-
          ```php
          private function ensureMinimumPrices(array $prices, int $kdv, RationalMoney $minimumUnitPrice): array
          {
              // Complex logic to ensure all components meet minimums
              // while maintaining mathematical consistency:
              // Unit Price with VAT = Unit Price without VAT + VAT Amount

              if ($prices['unit_kdv_amount']->isLessThan($minimumUnitPrice)) {
                  // Recalculate from KDV amount to ensure minimum
                  return $this->adjustFromKdvAmount($minimumUnitPrice, $kdv);
              }
              // ... other adjustments
          }
          ```
  -
    type: paragraph
    content:
      -
        type: text
        text: 'This ensures that even when dealing with very small amounts or high-volume transactions, every component remains valid while the total remains accurate.'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'The State Machine Integration'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'This entire process is orchestrated through our Event Machine, ensuring that rounding corrections only happen after all calculations are complete and validated:'
  -
    type: set
    attrs:
      id: code-state-calculate
      values:
        type: code
        code: |-
          ```php
          'calculate' => [
              'on' => [
                  '@always' => [
                      'actions' => [
                          CalculateNewForwardPriceAction::class,      // RationalMoney calculations
                          UpdateOrderItemsAction::class,              // Includes rounding handling
                      ],
                  ],
              ],
          ],
          ```
  -
    type: paragraph
    content:
      -
        type: text
        text: "By treating rounding differences as explicit discounts rather than hidden adjustments, we've created a system that is both mathematically precise and completely transparent. This approach has eliminated reconciliation issues while maintaining the trust of thousands of farmers who rely on our platform for fair and accurate pricing."
  -
    type: paragraph
    content:
      -
        type: text
        text: 'What started as a clever workaround during our precision migration became a permanent feature of our system. Even after completing the migration to '
      -
        type: text
        marks:
          -
            type: code
        text: 'DECIMAL(29,16)'
      -
        type: text
        text: ', we kept this automatic coupon system because it elegantly handles the final rounding step when converting from our high-precision calculations to the 2-decimal invoices that integrate with external accounting systems. It transformed a daily accounting burden into a fully automated, transparent process that requires zero manual intervention.'
  -
    type: heading
    attrs:
      level: 1
    content:
      -
        type: text
        text: 'State Machine Implementation with '
      -
        type: text
        marks:
          -
            type: code
        text: 'Event Machine'
      -
        type: text
        text: ' Package'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The entire IPS price calculation process is orchestrated using our open-source '
      -
        type: text
        marks:
          -
            type: link
            attrs:
              href: 'https://github.com/tarfin-labs/event-machine'
              rel: 'noopener nofollow'
              target: _blank
              title: null
        text: 'Event Machine'
      -
        type: text
        text: ' package, which provides a robust state machine implementation for Laravel:'
  -
    type: set
    attrs:
      id: code-state-machine
      values:
        type: code
        code: |-
          ```php
          class IPSPriceCalculationMachine extends Machine
          {
              public static function definition(): ?MachineDefinition
              {
                  return MachineDefinition::define(
                      config: [
                          'id' => 'ips_price_calculation',
                          'initial' => 'idle',
                          'states' => [
                              'idle' => [
                                  'on' => [
                                      'START' => [
                                          'target' => 'calculate',
                                          'guards' => [
                                              OrderIsNotDemoGuard::class,
                                              OrderIsCompletedGuard::class,
                                              OrderIsUnpaidGuard::class,
                                          ],
                                      ],
                                  ],
                              ],
                              'calculate' => [
                                  'on' => [
                                      '@always' => [
                                          'target' => 'done',
                                          'actions' => [
                                              CalculateAndCacheMonthlyCropPriceAverageAction::class,
                                              CalculateNewForwardPriceAction::class,
                                              UpdateOrderItemsAction::class,
                                          ],
                                      ],
                                  ],
                              ],
                          ],
                      ],
                  );
              }
          }
          ```
  -
    type: paragraph
    content:
      -
        type: text
        text: 'This state machine ensures that price calculations only happen when all conditions are met and maintains a clear audit trail of the process.'
  -
    type: heading
    attrs:
      level: 1
    content:
      -
        type: text
        text: 'Real-World Testing: Mixed VAT Rates'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Our test suite includes complex scenarios like handling multiple VAT rates simultaneously:'
  -
    type: set
    attrs:
      id: code-mixed-vat-test
      values:
        type: code
        code: |-
          ```php
          #[Test]
          public function it_allocates_prices_proportionally_with_mixed_vat_rates(): void
          {
              // Products with 0%, 10%, and 20% VAT rates
              // Updating total from 10,000 USD to 12,000 USD
              // Each product gets proportional share
              // VAT calculations are preserved
              // Minimum price constraints are enforced
          }
          ```
  -
    type: heading
    attrs:
      level: 1
    content:
      -
        type: text
        text: 'Testing High-Precision Financial Calculations'
  -
    type: paragraph
    content:
      -
        type: text
        text: "Testing financial calculations with 16 decimal precision requires special attention. Here's how we approach it:"
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'String Comparison for Exact Matching'
  -
    type: set
    attrs:
      id: code-commission-test
      values:
        type: code
        code: |-
          ```php
          #[Test]
          public function it_calculates_commission_with_full_precision()
          {
              $amount = '999999.9999999999999999';
              $rate = '0.0000123456789012';
              $result = calculateCommission($amount, $rate);

              // Don't use floats for comparison!
              $this->assertEquals(
                  '12.3456789011999999',  // Expected as string
                  (string) $result->getAmount()
              );
          }
          ```
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Testing Rounding Boundaries'
  -
    type: set
    attrs:
      id: code-rounding-test
      values:
        type: code
        code: |-
          ```php
          #[Test]
          public function it_handles_rounding_at_16th_decimal()
          {
              $price = Money::of('99.9999999999999999', 'USD', new CustomContext(16));
              $quantity = '1.0000000000000001';
              $total = $price->multipliedBy($quantity, RoundingMode::HALF_UP);

              // Test that rounding occurs correctly at the 16th decimal
              $this->assertEquals(
                  '100.0000000000000099',  // Correct result after rounding
                  (string) $total->getAmount()
              );
          }
          ```
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Testing Edge Cases'
  -
    type: set
    attrs:
      id: code-max-decimal-test
      values:
        type: code
        code: |-
          ```php
          #[Test]
          public function it_handles_maximum_decimal_values()
          {
              // Maximum value for DECIMAL(29,16)
              $maxValue = '9999999999999.9999999999999999';
              $money = Money::of($maxValue, 'USD', new CustomContext(16));

              // Ensure no overflow or precision loss
              $this->assertEquals($maxValue, (string) $money->getAmount());

              // Test that adding would exceed DECIMAL(29,16) limits
              $result = $money->plus(Money::of('0.0000000000000001', 'USD', new CustomContext(16)));

              // Result exceeds database storage limits
              $this->assertEquals(
                  '10000000000000.0000000000000000',
                  (string) $result->getAmount()
              );

              // This value cannot be stored in DECIMAL(29,16)
              // Database insertion would fail with:
              // "Out of range value for column 'amount'"
          }
          ```
  -
    type: heading
    attrs:
      level: 1
    content:
      -
        type: text
        text: 'Key Learnings and Recommendations'
  -
    type: orderedList
    attrs:
      start: 1
    content:
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Never use floats'
              -
                type: text
                text: ': '
              -
                type: text
                marks:
                  -
                    type: code
                text: IEEE-754
              -
                type: text
                text: ' binary floating point is not suitable for financial calculations'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Use String/BigDecimal'
              -
                type: text
                text: ': Process without precision loss'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Store sufficient decimals'
              -
                type: text
                text: ': 2 decimals are insufficient for modern fintech'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Test edge cases'
              -
                type: text
                text: ': Always test with very large and very small numbers'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Watch for chained operations'
              -
                type: text
                text: ': Errors compound exponentially'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Define rounding strategy'
              -
                type: text
                text: ': Consider automatic correction mechanisms like ours'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Use state machines'
              -
                type: text
                text: ': Complex financial processes benefit from explicit state management'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: code
                text: 'DECIMAL(29,16)'
              -
                type: text
                marks:
                  -
                    type: bold
                text: ' is powerful'
              -
                type: text
                text: ': Supports up to 9,999,999,999,999.9999999999999999 - more than enough for most'
              -
                type: hardBreak
              -
                type: text
                text: 'financial applications'
  -
    type: heading
    attrs:
      level: 1
    content:
      -
        type: text
        text: Conclusion
  -
    type: paragraph
    content:
      -
        type: text
        text: 'In financial technology, we need to think not in terms of "cents" but in terms of "0.0000000000000001 cents". Over millions of transactions, these tiny differences can compound into significant losses.'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Moving to '
      -
        type: text
        marks:
          -
            type: code
        text: 'DECIMAL(29,16)'
      -
        type: text
        text: ' precision - with 13 digits before and 16 after the decimal point - has eliminated rounding errors, enabled more sophisticated financial products, and given us the confidence that every cent is accounted for accurately. This precision allows us to handle amounts up to 9,999,999,999,999.9999999999999999 USD, which covers all our current and foreseeable future needs.'
  -
    type: horizontalRule
  -
    type: paragraph
    content:
      -
        type: text
        marks:
          -
            type: italic
        text: "This article is based on the production implementation of Tarfin's Income Protected Sales (IPS) model. The code examples are from our actual codebase, demonstrating real-world fintech challenges and solutions."
  -
    type: paragraph
    content:
      -
        type: text
        marks:
          -
            type: italic
        text: 'The '
      -
        type: text
        marks:
          -
            type: link
            attrs:
              href: 'https://github.com/tarfin-labs/event-machine'
              rel: 'noopener nofollow'
              target: _blank
              title: null
          -
            type: italic
        text: 'Event Machine'
      -
        type: text
        marks:
          -
            type: italic
        text: ' package mentioned in this article is open-source and available for use in your Laravel projects.'
---
