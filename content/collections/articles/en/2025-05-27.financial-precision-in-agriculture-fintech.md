---
id: 07b11a80-824a-42ce-a84d-8b5fcad94cc4
blueprint: articles
title: 'Financial Precision in Agriculture Fintech'
subtitle: 'Our Journey from 2 to 16 Decimal Places'
updated_by: b8f3533e-0fcf-42b9-a3d8-c8691deaf917
updated_at: 1765918485
content:
  -
    type: paragraph
    content:
      -
        type: text
        text: 'At '
      -
        type: text
        marks:
          -
            type: link
            attrs:
              href: 'https://www.tarfin.com/'
              rel: 'noopener nofollow'
              target: _blank
              title: null
        text: Tarfin
      -
        type: text
        text: ", Europe's leading fintech platform for farmer agri-input financing, thousands of farmers have chosen us to purchase their seeds, fertilizers, feed and equipment with flexible payment terms. Founded in 2017 in Turkey, we help farmers across 75+ cities by letting them compare prices from 1200+ retailers and purchase agri-inputs without tying up their cash. Since 2021, we've expanded to Romania, bringing the same farmer-friendly financing model to help small and medium-sized farmers access agricultural inputs without guarantees or hidden costs."
  -
    type: paragraph
    content:
      -
        type: text
        text: "When we started building our system, we followed the best practices known at the time: storing monetary values as integers in the database to avoid floating-point rounding issues. However, as our business grew and became more sophisticated, we discovered that even this approach wasn't sufficient. This article shares our journey of migrating from 2 decimal precision to a "
      -
        type: text
        marks:
          -
            type: code
        text: 'DECIMAL(29,16)'
      -
        type: text
        text: " structure in our database - that's 13 digits before the decimal point and 16 after."
  -
    type: set
    attrs:
      id: mj91r171
      values:
        type: heading
        heading: 'The Foundation: Brick/Money Library'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'After experiencing the limitations of integer storage, we adopted the '
      -
        type: text
        marks:
          -
            type: link
            attrs:
              href: 'https://github.com/brick/money'
              rel: 'noopener nofollow'
              target: _blank
              title: null
        text: Brick/Money
      -
        type: hardBreak
      -
        type: text
        text: 'library for all monetary operations in our Laravel application:'
  -
    type: set
    attrs:
      id: mj926som
      values:
        type: code
        code: |-
          ```php
          use Brick\Math\RoundingMode;  
          use Brick\Money\Money;  
          use Brick\Money\Context\CustomContext;  
            
          // Before: 2 decimal precision  
          $context2 = new CustomContext(2);  
          $price = Money::of(999.99, "USD", $context2);  
          $commission = $price->multipliedBy("0.025", RoundingMode::HALF_UP); // 25 USD  
            
          // After: 16 decimal precision  
          $context16 = new CustomContext(16);  
          $price = Money::of("999.9999999999999", "USD", $context16);  
          $commission = $price->multipliedBy("0.025", RoundingMode::HALF_UP); // 24.9999999999999975 USD  
          ```
  -
    type: set
    attrs:
      id: mj927ddj
      values:
        type: heading
        heading: 'Our Starting Point: Integer Storage'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'When we started building Tarfin, we knew about the dangers of floating-point arithmetic. The classic example every developer learns:'
  -
    type: set
    attrs:
      id: mj927pv2
      values:
        type: code
        code: |-
          ```php
          // The famous floating-point precision problem  
          $a = 0.1;  
          $b = 0.2;  
          $sum = $a + $b;  
            
          var_dump($sum === 0.3); // bool(false)!  
          printf("%.17f", $sum);  // 0.30000000000000004  

          ```
  -
    type: paragraph
    content:
      -
        type: text
        text: 'This happens because computers store floating-point numbers in binary (base 2), and many decimal fractions cannot be represented exactly in binary. Just like 1/3 cannot be precisely represented in decimal (0.333...), 0.1 cannot be precisely represented in binary.'
  -
    type: paragraph
    content:
      -
        type: text
        text: "That's why we followed the best practice of storing monetary values as integers:"
  -
    type: set
    attrs:
      id: mj928tpb
      values:
        type: code
        code: |-
          ```php
          // Instead of storing 100.50 USD as float  
          $price = 100.50; // Dangerous!  
            
          // We stored it as integer cents  
          $priceInCents = 10050; // Safe from floating-point errors  
          ```
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The integer storage approach had several advantages:'
  -
    type: set
    attrs:
      id: mj929628
      values:
        type: heading
        heading: 'Exact Representation'
  -
    type: set
    attrs:
      id: mj929ewi
      values:
        type: code
        code: |-
          ```php
          // Float storage problems  
          $dbPrice = 19.99;  
          $quantity = 3;  
          $total = $dbPrice * $quantity; // 59.97... or is it?  
          printf("%.17f", $total); // 59.96999999999999886  
            
          // Integer storage (cents)  
          $dbPriceCents = 1999;  
          $quantity = 3;  
          $totalCents = $dbPriceCents * $quantity; // Exactly 5997  
          $totalUSD = $totalCents / 100; // 59.97  
          ```
  -
    type: set
    attrs:
      id: mj929nn8
      values:
        type: heading
        heading: 'Consistent Database Operations'
  -
    type: codeBlock
    attrs:
      language: sql
    content:
      -
        type: text
        text: |
          -- Float columns can have comparison issues  
          SELECT *  
          FROM orders  
          WHERE total = 59.97;  
          -- Might miss rows!  
            
          -- Integer columns are reliable  
          SELECT *  
          FROM orders  
          WHERE total_cents = 5997; -- Always works  
  -
    type: heading
    attrs:
      level: 3
    content:
      -
        type: text
        text: 'No Accumulating Errors'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          // Float accumulation problem  
          $balance = 0.0;  
          for ($i = 0; $i < 10000; $i++) {  
              $balance += 0.01;}  
          echo $balance; // 100.00000000001 (should be 100.00)   
                         // Note: exact error may vary by system/PHP version  
            
          // Integer accumulation is perfect  
          $balanceCents = 0;  
          for ($i = 0; $i < 10000; $i++) {  
              $balanceCents += 1;}  
          echo $balanceCents / 100; // Exactly 100.00  
  -
    type: paragraph
    content:
      -
        type: text
        text: 'This integer approach worked well for amounts with 2 decimal places, but our business requirements soon exceeded these'
      -
        type: hardBreak
      -
        type: text
        text: limitations.
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: "Why 2 Decimal Places Weren't Enough"
  -
    type: heading
    attrs:
      level: 3
    content:
      -
        type: text
        text: 'Income Protected Sales (IPS)'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Our Income Protected Sales (IPS) model - what we call "Gelir KorumalÄ± SatÄ±ÅŸ" in Turkish - is essentially a commodity'
      -
        type: hardBreak
      -
        type: text
        text: 'price hedging mechanism for farmers. In this payment system, farmers can choose to pay based on the average commodity'
      -
        type: hardBreak
      -
        type: text
        text: 'prices at their selected payment date, rather than the purchase date. This protects them from price volatility in'
      -
        type: hardBreak
      -
        type: text
        text: 'agricultural markets.'
  -
    type: paragraph
    content:
      -
        type: text
        text: "For example, a farmer buying fertilizer in March can choose to pay in October based on October's wheat prices. If wheat"
      -
        type: hardBreak
      -
        type: text
        text: "prices rise, they pay less; if prices fall, they're protected by minimum price guarantees. This hedging mechanism"
      -
        type: hardBreak
      -
        type: text
        text: 'requires extreme precision in calculations:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          // Example: 1000 USD sale equals 100kg of wheat  
          $cashPrice = '1000.00';  
          $wheatAmount = '100.1234567890123456'; // kg  
          $wheatPrice = '9.876543210987654321'; // USD/kg  
            
          // With 2 decimals:  
          $result = round(100.12 * 9.88, 2); // 989.19 USD  
            
          // Actual value:  
          $result = '989.1851851851851851...'; // Significant difference!  
  -
    type: heading
    attrs:
      level: 3
    content:
      -
        type: text
        text: 'VAT Calculations on Small Unit Price Products'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Seeds and similar agricultural inputs often have very small unit prices but are purchased in large quantities. This is'
      -
        type: hardBreak
      -
        type: text
        text: 'where VAT (KDV in Turkish) calculation precision becomes critical:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          // Example: Seed with small unit price  
          $unitPrice = '0.05'; // 0.05 USD per seed  
          $quantity = 100000; // Farmer buys 100,000 seeds  
          $vatRate = 8; // 8% VAT  
            
          // With 2 decimal precision:  
          $unitPriceWithoutVat = round(0.05 / 1.08, 2); // 0.05 USD (wrong!)  
          $vatAmount = 0.00; // No VAT calculated!  
            
          // With 16 decimal precision:  
          $unitPriceWithoutVat = '0.0462962962962963'; // Correct  
          $vatAmount = '0.0037037037037037'; // Correct VAT  
            
          // For 100,000 seeds:  
          // 2 decimals: 0 USD VAT loss  
          // 16 decimals: 370.37 USD VAT correctly calculated  
  -
    type: paragraph
    content:
      -
        type: text
        text: 'When farmers purchase tens or hundreds of thousands of these small-unit items, rounding errors compound into significant'
      -
        type: hardBreak
      -
        type: text
        text: amounts.
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Float vs String: The IEEE-754 Problem'
  -
    type: heading
    attrs:
      level: 3
    content:
      -
        type: text
        text: 'What is IEEE-754?'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'IEEE-754 is the standard for floating-point arithmetic used by virtually all modern computers. It represents numbers in'
      -
        type: hardBreak
      -
        type: text
        text: 'binary (base 2) using three components:'
  -
    type: bulletList
    content:
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Sign bit'
              -
                type: text
                text: ': Positive or negative'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: Exponent
              -
                type: text
                text: ': The magnitude of the number'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Mantissa (fraction)'
              -
                type: text
                text: ': The precision bits'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The problem is that many decimal fractions cannot be exactly represented in binary. Just as 1/3 becomes 0.333... ('
      -
        type: hardBreak
      -
        type: text
        text: 'infinite) in decimal, numbers like 0.1 become infinite in binary:'
  -
    type: codeBlock
    attrs:
      language: null
    content:
      -
        type: text
        text: |
          0.1 in decimal = 0.00011001100110011... in binary (repeating forever)  
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Since computers have finite memory, they must truncate this infinite representation, leading to rounding errors.'
  -
    type: paragraph
    content:
      -
        type: text
        text: '[INSERT IEEE-754 DIAGRAM HERE]'
  -
    type: heading
    attrs:
      level: 3
    content:
      -
        type: text
        text: 'The Mental Shift: From Float to String'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Moving from writing '
      -
        type: text
        marks:
          -
            type: code
        text: '$amount = 1234.567'
      -
        type: text
        text: ' to '
      -
        type: text
        marks:
          -
            type: code
        text: "$amount = '999999.9999999999999999'"
      -
        type: text
        text: ' requires a fundamental mental shift'
      -
        type: hardBreak
      -
        type: text
        text: 'for developers. It feels unnatural at first to treat numbers as strings, but this becomes inevitable when working with'
      -
        type: hardBreak
      -
        type: text
        text: 'high-precision financial calculations - these precise decimal values simply cannot fit within the IEEE-754 standard'
      -
        type: hardBreak
      -
        type: text
        text: 'without loss of precision.'
  -
    type: heading
    attrs:
      level: 3
    content:
      -
        type: text
        text: 'Real Examples from Our System'
  -
    type: paragraph
    content:
      -
        type: text
        text: "Here's something that surprised us: Laravel returns DECIMAL database values as strings, not floats. At first, this"
      -
        type: hardBreak
      -
        type: text
        text: 'seemed odd - why would a numeric database type come back as a string? The answer reveals a deeper truth about precision.'
  -
    type: paragraph
    content:
      -
        type: text
        text: "PDO (PHP's database layer) returns DECIMAL values as strings because PHP's float type cannot accurately represent many"
      -
        type: hardBreak
      -
        type: text
        text: 'decimal values. By returning strings, it preserves the exact precision stored in your database. The danger comes when'
      -
        type: hardBreak
      -
        type: text
        text: 'developers, not understanding this protection, convert these strings to floats:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          use Brick\Money\Context\CustomContext;  
          use Brick\Money\Money;  
            
          $context = new CustomContext(16);  
            
          // PDO correctly returns DECIMAL as string to preserve precision  
          $dbAmount = "999999.9999999999999999"; // From DECIMAL(29,16) column  
            
          // String preserves exact value  
          $moneyStr = Money::of($dbAmount, "USD", $context);  
          // Money amount: 999999.9999999999999999  
            
          // Developer "helps" by converting to float - DESTROYS precision!  
          $moneyFloat = Money::of((float) $dbAmount, "USD", $context);  
          // Money amount: 1000000  
            
          // That's a 0.0000000000000001 USD difference that became 1 cent!  
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The real danger comes from compounding errors in chained operations:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          // Chained operations with 16 decimal precision  
          $dbPrice = '99999.1234567890123456';  
          $dbDiscount = '0.1234567890123456';    // ~12.35% discount  
          $dbTax = '0.2000000000000001';         // 20% VAT  
          $dbCommission = '0.0123456789012345';   // Platform commission  
            
          // String approach: preserves all precision  
          // Float approach: compounds errors at each step  
          // Difference after 4 operations: 0.0000000006 USD  
            
          // Imagine processing thousands of transactions daily!  
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Performance Considerations'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'You might worry about performance when using strings instead of floats. In our experience:'
  -
    type: bulletList
    content:
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'The performance difference is negligible for most operations'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'The accuracy gained far outweighs any minimal performance cost'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'Database indexes work perfectly with DECIMAL(29,16) columns'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'Modern databases are optimized for decimal arithmetic'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'However, there are trade-offs to consider:'
  -
    type: bulletList
    content:
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: Storage
              -
                type: text
                text: ': Higher precision means more storage space. DECIMAL(29,16) uses more bytes than DECIMAL(10,2)'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Bulk Operations'
              -
                type: text
                text: ': When processing hundreds or thousands of calculations, string-based arithmetic is slower than'
              -
                type: hardBreak
              -
                type: text
                text: 'native float operations'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'The Right Balance'
              -
                type: text
                text: ': DECIMAL(29,16) was our sweet spot, but your application might need different precision based on'
              -
                type: hardBreak
              -
                type: text
                text: 'your specific requirements'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The Brick/Money library mitigates performance impacts by using optimized arbitrary-precision arithmetic libraries like'
      -
        type: hardBreak
      -
        type: text
        text: 'BCMath or GMP under the hood. These extensions are specifically designed for high-precision calculations and offer the'
      -
        type: hardBreak
      -
        type: text
        text: 'best balance between accuracy and performance for financial applications.'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Laravel Implementation Best Practices'
  -
    type: heading
    attrs:
      level: 3
    content:
      -
        type: text
        text: 'Model Casting'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Our journey with Laravel model casting evolved through several stages, following our database evolution:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          // Stage 0: INTEGER storage (cents) ðŸ’°  
          // Database: amount BIGINT (stored as cents)  
          protected $casts = [  
              'amount' => 'integer',  // 10050 cents = 100.50 USD];  
  -
    type: paragraph
    content:
      -
        type: text
        text: 'When we started, we stored monetary values as integers in cents. This worked well for avoiding floating-point issues,'
      -
        type: hardBreak
      -
        type: text
        text: 'but limited us to 2 decimal precision.'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'After migrating to DECIMAL storage, we discovered something crucial: MySQL returns DECIMAL values as strings to PHP,'
      -
        type: hardBreak
      -
        type: text
        text: "while FLOAT/DOUBLE columns return as numbers. This happens because DECIMAL values can have precision that exceeds PHP's"
      -
        type: hardBreak
      -
        type: text
        text: 'float capacity (~15 significant digits).'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          // Stage 1: WRONG - Don't cast DECIMAL to float! âŒ  
          protected $casts = [  
              'amount' => 'float',  // This destroys precision!];  
          // Database value: '999.9999999999999999'  
          // After float cast: 1000.0  
  -
    type: paragraph
    content:
      -
        type: text
        text: "We never actually implemented Stage 1 in production, but it's a common mistake developers make when transitioning from"
      -
        type: hardBreak
      -
        type: text
        text: 'integer to decimal storage.'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          // Stage 2: BETTER - Preserve string from database âœ…  
          protected $casts = [  
              'amount' => 'string',  // Keeps '999.9999999999999999' intact];  
  -
    type: paragraph
    content:
      -
        type: text
        text: 'This was our first working solution with DECIMAL columns. By keeping values as strings, we preserved all precision from'
      -
        type: hardBreak
      -
        type: text
        text: 'the database. However, we still had to manually convert to Money objects everywhere.'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          // Stage 3: GOOD - Custom Money cast with 2 decimal precision âœ… âœ…  
          protected $casts = [  
              'amount' => MoneyCast::class . ':2',  // Auto-converts to Money object];  
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Creating a custom cast was a game-changer. Our MoneyCast automatically handled the conversion between DECIMAL database'
      -
        type: hardBreak
      -
        type: text
        text: 'columns and Money objects.'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          // Stage 4: BEST - Custom Money cast with 16 decimal precision âœ…âœ…âœ…  
          protected $casts = [  
              'amount' => MoneyCast::class . ':16',  // Full precision Money objects];  
            
          // Full precision maintained throughout the stack  
          $money = $model->amount; // Money object with 16 decimal precision  
          $preciseCalculation = $money->multipliedBy('1.0000000000000001');  
  -
    type: paragraph
    content:
      -
        type: text
        text: 'As we discovered edge cases with seeds, VAT calculations, and Income Protected Sales, we upgraded to 16 decimal'
      -
        type: hardBreak
      -
        type: text
        text: 'precision. This custom cast automatically handles the conversion between our DECIMAL(29,16) database column and Money'
      -
        type: hardBreak
      -
        type: text
        text: 'objects, ensuring precision is maintained throughout the application lifecycle.'
  -
    type: heading
    attrs:
      level: 3
    content:
      -
        type: text
        text: 'Database-Level Precision Verification'
  -
    type: paragraph
    content:
      -
        type: text
        text: "When we chose DECIMAL(29,16), we naturally expected MySQL to handle the precision correctly - after all, that's the"
      -
        type: hardBreak
      -
        type: text
        text: 'whole point of the DECIMAL type. But given the critical nature of financial calculations, we decided to verify this'
      -
        type: hardBreak
      -
        type: text
        text: 'assumption with comprehensive tests.'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Our curiosity paid off with reassuring results:'
  -
    type: codeBlock
    attrs:
      language: sql
    content:
      -
        type: text
        text: |
          -- Test: Can MySQL accurately sum 10 tiny values?  
          -- 10 x 0.0000000000000001 should equal exactly 0.0000000000000010  
          SELECT SUM(amount) = 0.0000000000000010 as is_exact  
          FROM precision_test  
          WHERE amount = 0.0000000000000001;  
          -- Result: 1 (TRUE) âœ“  
            
          -- Test: Can MySQL detect differences at the 16th decimal?  
          SELECT amount,  
                 amount = 100.0000000000000000 as equals_100FROM precision_test  
          WHERE amount IN (100.0000000000000000, 100.0000000000000001);  
          -- Results show it correctly distinguishes between the values âœ“  
  -
    type: paragraph
    content:
      -
        type: text
        text: "These tests confirmed what we hoped: MySQL's DECIMAL implementation is rock-solid. Aggregate functions preserve all"
      -
        type: hardBreak
      -
        type: text
        text: 'decimal places, comparisons work at full precision, and there are no accumulation errors. This means database-level'
      -
        type: hardBreak
      -
        type: text
        text: "calculations (when needed for performance) won't compromise precision."
  -
    type: paragraph
    content:
      -
        type: text
        text: "However, this doesn't change our golden rule: always pass DECIMAL values as strings to PHP and use Money objects for"
      -
        type: hardBreak
      -
        type: text
        text: 'application-level calculations. The database handles storage and basic operations perfectly, but complex business logic'
      -
        type: hardBreak
      -
        type: text
        text: 'belongs in the application layer with proper money handling libraries.'
  -
    type: heading
    attrs:
      level: 3
    content:
      -
        type: text
        text: 'Database Migration'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'When we decided to move from integer to DECIMAL(29,16), the migration process taught us valuable lessons:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          Schema::table('transactions', function (Blueprint $table) {  
              // OLD: Stored as unsigned big integer (minor units)    $table->unsignedBigInteger('amount'); // Stored in cents  
                  // NEW: 13 integer digits + 16 decimal places = 29 total precision  
              $table->decimal('amount', 29, 16);  
          });  
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The actual migration required careful data conversion:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          public function up()  
          {  
              // Step 1: Add temporary decimal column    Schema::table('transactions', function (Blueprint $table) {        $table->decimal('amount_decimal', 29, 16)->nullable();    });  
              // Step 2: Convert cents to dollars (divide by 100!)    DB::statement('UPDATE transactions SET amount_decimal = amount / 100');  
              // Step 3: Swap columns    Schema::table('transactions', function (Blueprint $table) {        $table->dropColumn('amount');        $table->renameColumn('amount_decimal', 'amount');    });}  
  -
    type: heading
    attrs:
      level: 3
    content:
      -
        type: text
        text: 'Money Service Integration'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          use Brick\Money\Context\CustomContext;  
          use Brick\Money\Money;  
            
          // Context with 16 decimal precision  
          $context = new CustomContext(16);  
            
          // With DECIMAL(29,16), we can store:  
          // Max: 9,999,999,999,999.9999999999999999 USD (13 digits before, 16 after)  
          // This is well within safe number ranges for both PHP and JavaScript  
            
          // Always pass strings to Money::of()  
          $money = Money::of($dbAmount, "USD", $context); // Precision preserved  
            
          // DECIMAL(29,16) handles large amounts perfectly  
          $largeAmount = "9999999999999.9999999999999999"; // Max for DECIMAL(29,16)  
          $money = Money::of($largeAmount, "USD", $context); // Works perfectly  
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Common Pitfalls When Working with High Precision'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'After implementing DECIMAL(29,16) and proper model casting, we discovered several non-obvious pitfalls in production:'
  -
    type: heading
    attrs:
      level: 3
    content:
      -
        type: text
        text: 'External Data Sources'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The biggest challenges come from data entering your system:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          // âŒ WRONG: Trusting external number formats$csvImport = "1.234,56"; // European format from Excel  
          $apiResponse = ["amount" => 1.0e-16]; // Scientific notation  
            
          // âœ… CORRECT: Normalize before processing$normalized = str_replace(',', '.', str_replace('.', '', $csvImport)); // Remove thousands separator first  
          $apiAmount = sprintf('%.16f', $apiResponse['amount']); // Convert scientific to decimal  
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Money library will throw '
      -
        type: text
        marks:
          -
            type: code
        text: NumberFormatException
      -
        type: text
        text: ' for invalid formats, which is good - but it means you need robust input'
      -
        type: hardBreak
      -
        type: text
        text: 'validation in your data pipelines.'
  -
    type: heading
    attrs:
      level: 3
    content:
      -
        type: text
        text: 'JSON Encoding Concerns'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'When sending monetary values through APIs:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          use Brick\Money\Context\CustomContext;  
          use Brick\Money\Money;  
            
          $context = new CustomContext(16);  
            
          // âŒ RISKY: Direct JSON encoding might use scientific notation$data = ["amount" => 0.0000000000000001];  
          echo json_encode($data); // {"amount":1.0e-16} - Precision lost!  
            
          // âœ… CORRECT: Always use strings$money = Money::of("0.0000000000000001", "USD", $context);  
          $data = ["amount" => (string) $money->getAmount()]; // Cast to string  
          echo json_encode($data); // {"amount":"0.0000000000000001"}  
            
          // Also watch out for json_decode!  
          $json = '{"price": 0.0000000000000001}';  
          $decoded = json_decode($json, true); // $decoded['price'] is float!  
          $decodedSafe = json_decode($json, true, 512, JSON_BIGINT_AS_STRING);  
  -
    type: paragraph
    content:
      -
        type: text
        text: 'These real-world issues taught us that high precision requires vigilance not just in calculations, but throughout your'
      -
        type: hardBreak
      -
        type: text
        text: 'entire data flow.'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Creative Solution: Automatic Discount Coupons for Rounding Differences'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'While we were working on our migration from 2 to 16 decimal precision - a significant infrastructure change that would'
      -
        type: hardBreak
      -
        type: text
        text: 'take months to complete - we needed an immediate solution for the rounding differences that were causing daily headaches'
      -
        type: hardBreak
      -
        type: text
        text: 'for our accounting team. Every invoice with a rounding discrepancy meant manual reconciliation work, explanations to'
      -
        type: hardBreak
      -
        type: text
        text: 'farmers, and additional burden on our finance department.'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'This led us to develop what we initially thought of as a temporary workaround but turned out to be an ingenious approach'
      -
        type: hardBreak
      -
        type: text
        text: 'that solved multiple problems at once. Rather than rushing the precision migration and risking errors, we could take our'
      -
        type: hardBreak
      -
        type: text
        text: "time to do it right while immediately eliminating the accounting team's reconciliation burden."
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The core challenge remained: while we perform all calculations using '
      -
        type: text
        marks:
          -
            type: code
        text: RationalMoney
      -
        type: text
        text: ' with infinite precision, our database'
      -
        type: hardBreak
      -
        type: text
        text: 'and financial systems could only store prices with 2 decimal places (0.01 USD minimum). This creates an inevitable'
      -
        type: hardBreak
      -
        type: text
        text: 'precision loss at the very last step - when we must convert our perfectly calculated rational numbers into storable'
      -
        type: hardBreak
      -
        type: text
        text: 'decimal values.'
  -
    type: heading
    attrs:
      level: 3
    content:
      -
        type: text
        text: 'The Mathematical Challenge'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Consider this scenario from our Income Protected Sales calculations:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          // Target total: 999.99 USD to be distributed across 3 items  
          // Item ratios: 40%, 35%, 25%  
            
          // Perfect rational calculation:  
          Item 1: 399.996 USD â†’ rounds to 400.00 USD  
          Item 2: 349.9965 USD â†’ rounds to 350.00 USD  Item 3: 249.9975 USD â†’ rounds to 250.00 USD  
            
          // Total after rounding: 1000.00 USD (0.01 USD over!)  
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Even though we maintain perfect precision throughout all calculations using '
      -
        type: text
        marks:
          -
            type: code
        text: RationalMoney
      -
        type: text
        text: ', the final conversion to'
      -
        type: hardBreak
      -
        type: text
        text: '2-decimal storage creates a 0.01 USD discrepancy. Across thousands of transactions, these penny differences could'
      -
        type: hardBreak
      -
        type: text
        text: 'accumulate into significant amounts.'
  -
    type: heading
    attrs:
      level: 3
    content:
      -
        type: text
        text: 'Our Intelligent Solution'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Rather than accepting this precision loss or attempting to "fudge" the numbers, we developed an automated system that'
      -
        type: hardBreak
      -
        type: text
        text: 'maintains both mathematical accuracy and accounting integrity. This solution immediately freed our accounting team from'
      -
        type: hardBreak
      -
        type: text
        text: 'manual reconciliation work while we continued our careful migration to 16 decimal precision:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          public function handleRoundingDifference(  
              IPSPriceCalculationContext $context,    int $allocatedTotal,    int $targetTotal): void {  
              $difference = $allocatedTotal - $targetTotal;    $threshold = config('tarfin.application.max_uncorrected_rounding_difference');  
              if ($difference > $threshold) {        // Create automatic coupon for the exact difference        $coupon = Coupon::create([            'code' => 'ROUND-'.Str::random(8),            'description' => 'Rounding Difference - Automatically created',            'redemption_limit' => 1,        ]);  
                  // Apply proportionally to maintain item ratios        $this->distributeCouponProportionally($coupon, $order, $difference);    }}  
  -
    type: heading
    attrs:
      level: 3
    content:
      -
        type: text
        text: 'How It Preserves Precision'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The key insight is that we perform all calculations at the '
      -
        type: text
        marks:
          -
            type: code
        text: RationalMoney
      -
        type: text
        text: ' level - with infinite precision - and only'
      -
        type: hardBreak
      -
        type: text
        text: 'encounter rounding when converting to database storage:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          private function calculateItemPrices(OrderItem $item, Money $allocatedAmount, RationalMoney $minimumUnitPrice): array  
          {  
              // Work with rational numbers for perfect precision    $unitWithKdv = $allocatedAmount->toRational()->dividedBy($item->quantity);        // All VAT calculations happen in rational space  
              $prices = $this->calculatePriceComponents($unitWithKdv, $item->kdv);        // Only at the very end do we convert to 2-decimal Money  
              return [        'unit_w_kdv' => $unitWithKdv,  // Still RationalMoney        'total_w_kdv_minor' => $totalWithKdv->to(new CustomContext(2), RoundingMode::HALF_UP)                                            ->getMinorAmount()->toInt()    ];}  
  -
    type: paragraph
    content:
      -
        type: text
        text: 'This approach ensures:'
  -
    type: orderedList
    attrs:
      start: 1
    content:
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Perfect calculation accuracy'
              -
                type: text
                text: ': All intermediate calculations use RationalMoney'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Transparent correction'
              -
                type: text
                text: ': Any rounding difference is explicitly recorded as a discount'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Proportional distribution'
              -
                type: text
                text: ': The discount is distributed maintaining the original price ratios'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Complete auditability'
              -
                type: text
                text: ': Every penny is accounted for in the system'
  -
    type: heading
    attrs:
      level: 3
    content:
      -
        type: text
        text: 'Real-World Example'
  -
    type: paragraph
    content:
      -
        type: text
        text: "From our test suite, here's how it works in practice:"
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          // Order with calculated forward price: 10,000.00 USD  
          // After allocation and rounding: 10,001.00 USD  
          // Difference: 1.00 USD  
            
          // System automatically:  
          // 1. Creates coupon ROUND-X8K2M9P1 for 1.00 USD  
          // 2. Distributes proportionally:  
          //    - Item 1 (60% of order): 0.60 USD discount  
          //    - Item 2 (40% of order): 0.40 USD discount  
          // 3. Final totals match exactly: 10,000.00 USD  
  -
    type: heading
    attrs:
      level: 3
    content:
      -
        type: text
        text: 'Handling Edge Cases with Minimum Constraints'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The solution becomes even more sophisticated when dealing with minimum price constraints. Each price component (unit'
      -
        type: hardBreak
      -
        type: text
        text: 'price, VAT amount) must be at least 0.01 USD:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          private function ensureMinimumPrices(array $prices, int $kdv, RationalMoney $minimumUnitPrice): array  
          {  
              // Complex logic to ensure all components meet minimums    // while maintaining mathematical consistency:    // Unit Price with VAT = Unit Price without VAT + VAT Amount        if ($prices['unit_kdv_amount']->isLessThan($minimumUnitPrice)) {  
                  // Recalculate from KDV amount to ensure minimum        return $this->adjustFromKdvAmount($minimumUnitPrice, $kdv);    }    // ... other adjustments}  
  -
    type: paragraph
    content:
      -
        type: text
        text: 'This ensures that even when dealing with very small amounts or high-volume transactions, every component remains valid'
      -
        type: hardBreak
      -
        type: text
        text: 'while the total remains accurate.'
  -
    type: heading
    attrs:
      level: 3
    content:
      -
        type: text
        text: 'The State Machine Integration'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'This entire process is orchestrated through our Event Machine, ensuring that rounding corrections only happen after all'
      -
        type: hardBreak
      -
        type: text
        text: 'calculations are complete and validated:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          'calculate' => [  
              'on' => [        '@always' => [            'actions' => [                CalculateNewForwardPriceAction::class,      // RationalMoney calculations                UpdateOrderItemsAction::class,              // Includes rounding handling            ],        ],    ],],  
  -
    type: paragraph
    content:
      -
        type: text
        text: "By treating rounding differences as explicit discounts rather than hidden adjustments, we've created a system that is"
      -
        type: hardBreak
      -
        type: text
        text: 'both mathematically precise and completely transparent. This approach has eliminated reconciliation issues while'
      -
        type: hardBreak
      -
        type: text
        text: 'maintaining the trust of thousands of farmers who rely on our platform for fair and accurate pricing.'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'What started as a clever workaround during our precision migration became a permanent feature of our system. Even after'
      -
        type: hardBreak
      -
        type: text
        text: 'completing the migration to DECIMAL(29,16), we kept this automatic coupon system because it elegantly handles the final'
      -
        type: hardBreak
      -
        type: text
        text: 'rounding step when converting from our high-precision calculations to the 2-decimal invoices that integrate with'
      -
        type: hardBreak
      -
        type: text
        text: 'external accounting systems. It transformed a daily accounting burden into a fully automated, transparent process that'
      -
        type: hardBreak
      -
        type: text
        text: 'requires zero manual intervention.'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'State Machine Implementation with Event Machine'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The entire IPS price calculation process is orchestrated using our'
      -
        type: hardBreak
      -
        type: text
        text: 'open-source '
      -
        type: text
        marks:
          -
            type: link
            attrs:
              href: 'https://github.com/tarfin-labs/event-machine'
              rel: 'noopener nofollow'
              target: _blank
              title: null
        text: 'Event Machine'
      -
        type: text
        text: ' package, which provides a robust state machine'
      -
        type: hardBreak
      -
        type: text
        text: 'implementation for Laravel:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          class IPSPriceCalculationMachine extends Machine  
          {  
              public static function definition(): ?MachineDefinition    {        return MachineDefinition::define(            config: [                'id' => 'ips_price_calculation',                'initial' => 'idle',                'states' => [                    'idle' => [                        'on' => [                            'START' => [                                'target' => 'calculate',                                'guards' => [                                    OrderIsNotDemoGuard::class,                                    OrderIsCompletedGuard::class,                                    OrderIsUnpaidGuard::class,                                ],                            ],                        ],                    ],                    'calculate' => [                        'on' => [                            '@always' => [                                'target' => 'done',                                'actions' => [                                    CalculateAndCacheMonthlyCropPriceAverageAction::class,                                    CalculateNewForwardPriceAction::class,                                    UpdateOrderItemsAction::class,                                ],                            ],                        ],                    ],                ],            ],        );    }}  
  -
    type: paragraph
    content:
      -
        type: text
        text: 'This state machine ensures that price calculations only happen when all conditions are met and maintains a clear audit'
      -
        type: hardBreak
      -
        type: text
        text: 'trail of the process.'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Real-World Testing: Mixed VAT Rates'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Our test suite includes complex scenarios like handling multiple VAT rates simultaneously:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          #[Test]  
          public function it_allocates_prices_proportionally_with_mixed_vat_rates(): void  
          {  
              // Products with 0%, 10%, and 20% VAT rates    // Updating total from 10,000 USD to 12,000 USD    // Each product gets proportional share    // VAT calculations are preserved    // Minimum price constraints are enforced}  
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Testing High-Precision Financial Calculations'
  -
    type: paragraph
    content:
      -
        type: text
        text: "Testing financial calculations with 16 decimal precision requires special attention. Here's how we approach it:"
  -
    type: heading
    attrs:
      level: 3
    content:
      -
        type: text
        text: 'String Comparison for Exact Matching'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          #[Test]  
          public function it_calculates_commission_with_full_precision()  
          {  
              $amount = '999999.9999999999999999';    $rate = '0.0000123456789012';    $result = calculateCommission($amount, $rate);  
                  // Don't use floats for comparison!  
              $this->assertEquals(  
                  '12.3456789011999999',  // Expected as string        (string) $result->getAmount()  
              );  
          }  
  -
    type: heading
    attrs:
      level: 3
    content:
      -
        type: text
        text: 'Testing Rounding Boundaries'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          #[Test]  
          public function it_handles_rounding_at_16th_decimal()  
          {  
              $price = Money::of('99.9999999999999999', 'USD', new CustomContext(16));  
              $quantity = '1.0000000000000001';    $total = $price->multipliedBy($quantity, RoundingMode::HALF_UP);  
                  // Test that rounding occurs correctly at the 16th decimal  
              $this->assertEquals(  
                  '100.0000000000000099',  // Correct result after rounding        (string) $total->getAmount()  
              );  
          }  
  -
    type: heading
    attrs:
      level: 3
    content:
      -
        type: text
        text: 'Testing Edge Cases'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          #[Test]  
          public function it_handles_maximum_decimal_values()  
          {  
              // Maximum value for DECIMAL(29,16)    $maxValue = '9999999999999.9999999999999999';    $money = Money::of($maxValue, 'USD', new CustomContext(16));  
                  // Ensure no overflow or precision loss  
              $this->assertEquals($maxValue, (string) $money->getAmount());  
                  // Test that adding would exceed DECIMAL(29,16) limits  
              $result = $money->plus(Money::of('0.0000000000000001', 'USD', new CustomContext(16)));  
                  // Result exceeds database storage limits  
              $this->assertEquals(  
                  '10000000000000.0000000000000000',        (string) $result->getAmount()  
              );  
                  // This value cannot be stored in DECIMAL(29,16)  
              // Database insertion would fail with:    // "Out of range value for column 'amount'"}  
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Key Learnings and Recommendations'
  -
    type: orderedList
    attrs:
      start: 1
    content:
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Never use floats'
              -
                type: text
                text: ': IEEE-754 binary floating point is not suitable for financial calculations'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Use String/BigDecimal'
              -
                type: text
                text: ': Process without precision loss'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Store sufficient decimals'
              -
                type: text
                text: ': 2 decimals are insufficient for modern fintech'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Test edge cases'
              -
                type: text
                text: ': Always test with very large and very small numbers'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Watch for chained operations'
              -
                type: text
                text: ': Errors compound exponentially'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Define rounding strategy'
              -
                type: text
                text: ': Consider automatic correction mechanisms like ours'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Use state machines'
              -
                type: text
                text: ': Complex financial processes benefit from explicit state management'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'DECIMAL(29,16) is powerful'
              -
                type: text
                text: ': Supports up to 9,999,999,999,999.9999999999999999 - more than enough for most'
              -
                type: hardBreak
              -
                type: text
                text: 'financial applications'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: Conclusion
  -
    type: paragraph
    content:
      -
        type: text
        text: 'In financial technology, we need to think not in terms of "cents" but in terms of "0.0000000000000001 cents". Over'
      -
        type: hardBreak
      -
        type: text
        text: 'millions of transactions, these tiny differences can compound into significant losses.'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Moving to '
      -
        type: text
        marks:
          -
            type: code
        text: 'DECIMAL(29,16)'
      -
        type: text
        text: ' precision - with 13 digits before and 16 after the decimal point - has eliminated rounding'
      -
        type: hardBreak
      -
        type: text
        text: 'errors, enabled more sophisticated financial products, and given us the confidence that every cent is accounted for'
      -
        type: hardBreak
      -
        type: text
        text: 'accurately. This precision allows us to handle amounts up to 9,999,999,999,999.9999999999999999 USD, which covers all'
      -
        type: hardBreak
      -
        type: text
        text: 'our current and foreseeable future needs.'
  -
    type: horizontalRule
  -
    type: paragraph
    content:
      -
        type: text
        marks:
          -
            type: italic
        text: "This article is based on the production implementation of Tarfin's Income Protected Sales (IPS) model. The code"
      -
        type: hardBreak
        marks:
          -
            type: italic
      -
        type: text
        marks:
          -
            type: italic
        text: 'examples are from our actual codebase, demonstrating real-world fintech challenges and solutions.'
  -
    type: paragraph
    content:
      -
        type: text
        marks:
          -
            type: italic
        text: 'The '
      -
        type: text
        marks:
          -
            type: link
            attrs:
              href: 'https://github.com/tarfin-labs/event-machine'
              rel: 'noopener nofollow'
              target: _blank
              title: null
          -
            type: italic
        text: 'Event Machine'
      -
        type: text
        marks:
          -
            type: italic
        text: ' package mentioned in this article is open-source and'
      -
        type: hardBreak
        marks:
          -
            type: italic
      -
        type: text
        marks:
          -
            type: italic
        text: 'available for use in your Laravel projects.'
---
