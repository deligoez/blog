---
id: 1ac3d237-677a-497d-978b-b84d06bed4ef
blueprint: articles
title: 'Self-Mocking Actions in Laravel'
subtitle: 'Building a Testable Action Pattern with Service Container Magic'
updated_by: b8f3533e-0fcf-42b9-a3d8-c8691deaf917
updated_at: 1765957438
content:
  -
    type: paragraph
    content:
      -
        type: text
        text: "You've embraced the Action pattern in your Laravel application. Your codebase is clean, responsibilities are separated, and each action does one thing well. Life is good."
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Then you start writing tests.'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |-
          #[Test]
          public function checkout_processes_payment_and_sends_receipt(): void
          {
              // Arrange - This setup is getting verbose...
              $paymentMock = Mockery::mock(ProcessPaymentAction::class);
              $this->app->instance(ProcessPaymentAction::class, $paymentMock);
              $paymentMock->shouldReceive('handle')
                  ->once()
                  ->andReturn($this->createPaymentResult());

              $receiptMock = Mockery::mock(SendPaymentReceiptAction::class);
              $this->app->instance(SendPaymentReceiptAction::class, $receiptMock);
              $receiptMock->shouldReceive('handle')->once();

              // Act
              $this->post('/checkout', $this->orderData);

              // Assert...
          }
  -
    type: paragraph
    content:
      -
        type: text
        text: "This works, but it's noisy. Every test needs three lines per mocked action: create mock, bind to container, set expectations. With five actions, that's fifteen lines of boilerplate before you even start testing."
  -
    type: paragraph
    content:
      -
        type: text
        text: 'What if you could write this instead?'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |-
          #[Test]
          public function checkout_processes_payment_and_sends_receipt(): void
          {
              ProcessPaymentAction::shouldRun()->once()->andReturn($this->createPaymentResult());
              SendPaymentReceiptAction::shouldRun()->with($this->order)->once();

              $this->post('/checkout', $this->orderData);
          }
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Clean. Readable. Laravel-native.'
  -
    type: paragraph
    content:
      -
        type: text
        text: "This pattern isn't magic: it's the same approach Laravel uses for "
      -
        type: text
        marks:
          -
            type: code
        text: 'Bus::fake()'
      -
        type: text
        text: ', '
      -
        type: text
        marks:
          -
            type: code
        text: 'Event::fake()'
      -
        type: text
        text: ', and '
      -
        type: text
        marks:
          -
            type: code
        text: 'Queue::fake()'
      -
        type: text
        text: ". In this article, we'll build a self-mocking Action base class that gives your actions first-class testing support."
  -
    type: set
    attrs:
      id: mj9p2cvq
      values:
        type: toc-auto
        levels:
          - 1
  -
    type: heading
    attrs:
      level: 1
    content:
      -
        type: text
        text: 'The Action Pattern Refresher'
  -
    type: paragraph
    content:
      -
        type: text
        text: "Before diving into the mocking solution, let's establish what we're working with. The Action pattern (sometimes called "
      -
        type: text
        marks:
          -
            type: link
            attrs:
              href: 'https://refactoring.guru/design-patterns/command'
              rel: null
              target: _blank
              title: null
        text: 'Command pattern'
      -
        type: text
        text: ') encapsulates a single business operation in its own class:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |-
          class ProcessPaymentAction
          {
              public function __construct(
                  private PaymentGateway $gateway,
                  private Logger $logger
              ) {}

              public function handle(Order $order, PaymentMethod $method): PaymentResult
              {
                  $this->logger->info("Processing payment for order {$order->id}");

                  $result = $this->gateway->charge(
                      amount: $order->total,
                      method: $method
                  );

                  if ($result->successful()) {
                      $order->markAsPaid($result->transactionId);
                  }

                  return $result;
              }
          }
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Actions are typically resolved from the container (to get their dependencies injected) and called via their '
      -
        type: text
        marks:
          -
            type: code
        text: handle()
      -
        type: text
        text: ' method. Many teams add static convenience methods:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |-
          // Instead of this:
          app(ProcessPaymentAction::class)->handle($order, $method);

          // You can write this:
          ProcessPaymentAction::run($order, $method);
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Actions are excellent for organization; each file represents one capability. But when '
      -
        type: text
        marks:
          -
            type: code
        text: 'Action A'
      -
        type: text
        text: ' calls '
      -
        type: text
        marks:
          -
            type: code
        text: 'Action B'
      -
        type: text
        text: ' calls '
      -
        type: text
        marks:
          -
            type: code
        text: 'Action C'
      -
        type: text
        text: ', testing becomes a '
      -
        type: text
        marks:
          -
            type: link
            attrs:
              href: 'https://en.wikipedia.org/wiki/Dependency_injection'
              rel: null
              target: null
              title: null
        text: 'dependency injection'
      -
        type: text
        text: " nightmare. That's where self-mocking comes in."
  -
    type: heading
    attrs:
      level: 1
    content:
      -
        type: text
        text: 'The Core Concept: Dual-Key Container Binding'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The key insight behind this pattern is simple: '
      -
        type: text
        marks:
          -
            type: bold
        text: 'store mocks under a different container key than the real class'
      -
        type: text
        text: .
  -
    type: paragraph
    content:
      -
        type: text
        text: 'When you normally mock a class, you replace its binding:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          $this->app->instance(PaymentAction::class, $mock);
  -
    type: paragraph
    content:
      -
        type: text
        text: "This works, but it's destructive; you've lost the original binding. If another test in the same process needs the real class, you're in trouble."
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Our approach uses a dual-key system:'
  -
    type: codeBlock
    attrs:
      language: null
    content:
      -
        type: text
        text: |
          Container Bindings:
          ┌─────────────────────────────────┬─────────────────────────────┐
          │ Key                             │ Value                       │
          ├─────────────────────────────────┼─────────────────────────────┤
          │ ProcessPaymentAction::class     │ Real instance (or binding)  │
          │ Fake:ProcessPaymentAction       │ Mock instance (when testing)│
          └─────────────────────────────────┴─────────────────────────────┘
  -
    type: paragraph
    content:
      -
        type: text
        text: 'When resolving the action:'
  -
    type: orderedList
    attrs:
      start: 1
    content:
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'Check if '
              -
                type: text
                marks:
                  -
                    type: code
                text: 'Fake:{ClassName}'
              -
                type: text
                text: ' exists'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'If yes, return the mock'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'If no, return the real instance'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'This preserves the original binding, allows clean teardown with '
      -
        type: text
        marks:
          -
            type: code
        text: clearFake()
      -
        type: text
        text: ', and lets multiple tests share the same application instance safely.'
  -
    type: heading
    attrs:
      level: 1
    content:
      -
        type: text
        text: 'Building the Base Action Class'
  -
    type: paragraph
    content:
      -
        type: text
        text: "Let's build this step by step. We'll create an abstract "
      -
        type: text
        marks:
          -
            type: code
        text: Action
      -
        type: text
        text: ' class that all your actions will extend.'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Container Methods'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'First, the static convenience methods for resolving and running actions:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          <?php

          namespace App\Actions;

          use Mockery;
          use Mockery\MockInterface;

          abstract class Action
          {
              /**
               * Resolve the Action from the container.
               */
              public static function make(): static
              {
                  return app(static::class);
              }

              /**
               * Resolve and immediately execute the Action.
               */
              public static function run(mixed ...$arguments): mixed
              {
                  return static::make()->handle(...$arguments);
              }
          }
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The '
      -
        type: text
        marks:
          -
            type: code
        text: 'static::class'
      -
        type: text
        text: ' ensures late static binding; when you call '
      -
        type: text
        marks:
          -
            type: code
        text: 'ProcessPaymentAction::make()'
      -
        type: text
        text: ', it resolves '
      -
        type: text
        marks:
          -
            type: code
        text: ProcessPaymentAction
      -
        type: text
        text: ', not '
      -
        type: text
        marks:
          -
            type: code
        text: Action
      -
        type: text
        text: .
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Fake Storage Methods'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Now the infrastructure for storing and retrieving mocks:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          abstract class Action
          {
              // ... previous methods ...

              /**
               * Check if this action has been faked.
               */
              public static function isFake(): bool
              {
                  return app()->isShared(static::getFakeResolvedInstanceKey());
              }

              /**
               * Remove the fake instance from the container.
               */
              public static function clearFake(): void
              {
                  app()->forgetInstance(static::getFakeResolvedInstanceKey());
              }

              /**
               * Store a mock instance in the container.
               */
              protected static function setFakeResolvedInstance(MockInterface $fake): MockInterface
              {
                  return app()->instance(static::getFakeResolvedInstanceKey(), $fake);
              }

              /**
               * Retrieve the stored mock instance.
               */
              protected static function getFakeResolvedInstance(): ?MockInterface
              {
                  return app(static::getFakeResolvedInstanceKey());
              }

              /**
               * Generate the container key for storing fakes.
               */
              protected static function getFakeResolvedInstanceKey(): string
              {
                  return 'Fake:' . static::class;
              }
          }
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The '
      -
        type: text
        marks:
          -
            type: code
        text: isShared()
      -
        type: text
        text: ' method checks if a key exists as a singleton in the container. We use '
      -
        type: text
        marks:
          -
            type: code
        text: forgetInstance()
      -
        type: text
        text: ' to clean up; this removes the fake binding without affecting the original class binding.'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'The Mocking API'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Now the public API that makes tests beautiful:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          abstract class Action
          {
              // ... previous methods ...

              /**
               * Create a mock for this action.
               * Returns existing mock if already faked.
               */
              public static function mock(): MockInterface
              {
                  if (static::isFake()) {
                      return static::getFakeResolvedInstance();
                  }

                  $mock = Mockery::mock(static::class);
                  $mock->shouldAllowMockingProtectedMethods();

                  return static::setFakeResolvedInstance($mock);
              }

              /**
               * Create a spy for this action.
               * Spies record calls but don't set expectations upfront.
               */
              public static function spy(): MockInterface
              {
                  if (static::isFake()) {
                      return static::getFakeResolvedInstance();
                  }

                  return static::setFakeResolvedInstance(Mockery::spy(static::class));
              }

              /**
               * Create a partial mock.
               * Real methods are called unless explicitly mocked.
               */
              public static function partialMock(): MockInterface
              {
                  return static::mock()->makePartial();
              }

              /**
               * Expect the action's handle() method to be called.
               */
              public static function shouldRun(): Mockery\Expectation
              {
                  return static::mock()
                      ->shouldReceive('handle')
                      ->because(class_basename(static::class) . ' should run but did not.');
              }

              /**
               * Expect the action's handle() method NOT to be called.
               */
              public static function shouldNotRun(): Mockery\Expectation
              {
                  return static::mock()
                      ->shouldNotReceive('handle')
                      ->because(class_basename(static::class) . ' should not run but it did.');
              }

              /**
               * Allow the action to run (spy mode) with optional return value.
               */
              public static function allowToRun(): Mockery\Expectation
              {
                  return static::spy()->allows('handle');
              }
          }
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Notice the '
      -
        type: text
        marks:
          -
            type: code
        text: '->because()'
      -
        type: text
        text: ' calls; these provide helpful error messages when expectations fail. Instead of '
      -
        type: text
        marks:
          -
            type: code
        text: 'Method handle() was not called.'
      -
        type: text
        text: ", you'll see "
      -
        type: text
        marks:
          -
            type: code
        text: 'ProcessPaymentAction should run but did not.'
  -
    type: heading
    attrs:
      level: 1
    content:
      -
        type: text
        text: 'The Magic: beforeResolving Hook Deep-Dive'
  -
    type: paragraph
    content:
      -
        type: text
        text: "We have a mock storage system, but there's a problem: when code calls "
      -
        type: text
        marks:
          -
            type: code
        text: 'ProcessPaymentAction::run()'
      -
        type: text
        text: ', it resolves via '
      -
        type: text
        marks:
          -
            type: code
        text: 'app(static::class)'
      -
        type: text
        text: ', which returns the real instance; not our mock.'
  -
    type: paragraph
    content:
      -
        type: text
        text: "We need to intercept the resolution process and swap in the mock when one exists. Laravel's service container provides the perfect hook: "
      -
        type: text
        marks:
          -
            type: code
        text: beforeResolving()
      -
        type: text
        text: .
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Understanding beforeResolving'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The '
      -
        type: text
        marks:
          -
            type: code
        text: beforeResolving()
      -
        type: text
        text: ' callback fires '
      -
        type: text
        marks:
          -
            type: bold
        text: before
      -
        type: text
        text: ' the container resolves any class:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          $this->app->beforeResolving(function ($abstract, $parameters, $app) {
              // $abstract is the class/interface being resolved
              // This runs BEFORE resolution happens
          });
  -
    type: paragraph
    content:
      -
        type: text
        text: 'This is different from '
      -
        type: text
        marks:
          -
            type: code
        text: afterResolving()
      -
        type: text
        text: ' (which fires after) or '
      -
        type: text
        marks:
          -
            type: code
        text: resolving()
      -
        type: text
        text: ' (which can modify the instance). We need '
      -
        type: text
        marks:
          -
            type: code
        text: beforeResolving()
      -
        type: text
        text: ' because we want to set up an extension before the first resolution.'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'The Action Manager'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'We need a manager class to:'
  -
    type: orderedList
    attrs:
      start: 1
    content:
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'Track which actions have been extended (to avoid duplicate extensions)'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'Set up the container extension when an Action is first resolved'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'Swap real instances with mocks when fakes exist'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          <?php

          namespace App\Actions;

          use Illuminate\Contracts\Foundation\Application;

          class ActionManager
          {
              /** @var array<string, bool> */
              protected array $extended = [];

              public function __construct(
                  protected Application $app
              ) {}

              /**
               * Extend an action class to support mock swapping.
               */
              public function extend(string $abstract): void
              {
                  // Already extended? Skip.
                  if ($this->isExtending($abstract)) {
                      return;
                  }

                  // Not an Action? Skip.
                  if (!$this->shouldExtend($abstract)) {
                      return;
                  }

                  // Set up the extension callback
                  $this->app->extend($abstract, function ($instance) use ($abstract) {
                      // If a fake exists, return it instead of the real instance
                      if (is_subclass_of($abstract, Action::class) && $instance::isFake()) {
                          return $instance::mock();
                      }

                      return $instance;
                  });

                  $this->extended[$abstract] = true;
              }

              public function isExtending(string $abstract): bool
              {
                  return isset($this->extended[$abstract]);
              }

              public function shouldExtend(string $abstract): bool
              {
                  return is_subclass_of($abstract, Action::class);
              }
          }
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The '
      -
        type: text
        marks:
          -
            type: code
        text: extend()
      -
        type: text
        text: ' method is key here. It registers a callback that Laravel will run '
      -
        type: text
        marks:
          -
            type: bold
        text: after
      -
        type: text
        text: ' resolving the class but '
      -
        type: text
        marks:
          -
            type: bold
        text: before
      -
        type: text
        text: ' returning it. This callback checks for a fake and swaps it in.'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Performance Consideration'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'You might worry about '
      -
        type: text
        marks:
          -
            type: code
        text: beforeResolving
      -
        type: text
        text: " being called for every single class resolution. That's a valid concern, but notice our guards:"
  -
    type: orderedList
    attrs:
      start: 1
    content:
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: code
                text: 'class_exists($abstract, false)'
              -
                type: text
                text: ' → only real classes, not interfaces or strings'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: code
                text: $app->resolved($abstract)
              -
                type: text
                text: ' → skip already-resolved singletons'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: code
                text: shouldExtend()
              -
                type: text
                text: ' → only '
              -
                type: text
                marks:
                  -
                    type: code
                text: Action
              -
                type: text
                text: ' subclasses get extended'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'In practice, the overhead is negligible → a few microseconds per resolution.'
  -
    type: heading
    attrs:
      level: 1
    content:
      -
        type: text
        text: 'Wiring It Up: The Service Provider'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Now we connect everything in a service provider:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          <?php

          namespace App\Providers;

          use App\Actions\Action;
          use App\Actions\ActionManager;
          use Illuminate\Foundation\Application;
          use Illuminate\Support\ServiceProvider;

          class ActionServiceProvider extends ServiceProvider
          {
              public function register(): void
              {
                  // Create the manager as a singleton
                  $manager = new ActionManager($this->app);
                  $this->app->instance(ActionManager::class, $manager);

                  // Hook into every class resolution
                  $this->app->beforeResolving(
                      function ($abstract, $parameters, Application $app) use ($manager): void {
                          // Skip non-classes and already-resolved bindings
                          if (!class_exists($abstract, false) || $app->resolved($abstract)) {
                              return;
                          }

                          $manager->extend($abstract);
                      }
                  );
              }
          }
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Register this provider in your '
      -
        type: text
        marks:
          -
            type: code
        text: config/app.php
      -
        type: text
        text: " (or it will auto-discover if you've set that up):"
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          'providers' => [
              // ...
              App\Providers\ActionServiceProvider::class,
          ],
  -
    type: paragraph
    content:
      -
        type: text
        text: "That's it. Every "
      -
        type: text
        marks:
          -
            type: code
        text: Action
      -
        type: text
        text: ' subclass now has full mocking support.'
  -
    type: heading
    attrs:
      level: 1
    content:
      -
        type: text
        text: 'Real-World Usage: Payment Processing Example'
  -
    type: paragraph
    content:
      -
        type: text
        text: "Let's see this pattern in action with a realistic example."
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'The Actions'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          // app/Actions/ProcessPaymentAction.php
          class ProcessPaymentAction extends Action
          {
              public function __construct(
                  private PaymentGateway $gateway
              ) {}

              public function handle(Order $order, PaymentMethod $method): PaymentResult
              {
                  $result = $this->gateway->charge($order->total, $method);

                  if ($result->successful()) {
                      $order->markAsPaid($result->transactionId);

                      // Trigger follow-up actions
                      SendPaymentReceiptAction::run($order, $result);
                      UpdateInventoryAction::run($order);
                  }

                  return $result;
              }
          }

          // app/Actions/SendPaymentReceiptAction.php
          class SendPaymentReceiptAction extends Action
          {
              public function __construct(
                  private Mailer $mailer
              ) {}

              public function handle(Order $order, PaymentResult $result): void
              {
                  $this->mailer->send(new PaymentReceiptMail($order, $result));
              }
          }

          // app/Actions/RefundPaymentAction.php
          class RefundPaymentAction extends Action
          {
              public function __construct(
                  private PaymentGateway $gateway
              ) {}

              public function handle(Order $order, string $reason): RefundResult
              {
                  $result = $this->gateway->refund($order->transactionId, $order->total);

                  if ($result->successful()) {
                      $order->markAsRefunded();
                      SendRefundNotificationAction::run($order, $reason);
                  }

                  return $result;
              }
          }
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Test Examples'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          class CheckoutTest extends TestCase
          {
              protected function setUp(): void
              {
                  parent::setUp();

                  // Clear any fakes from previous tests
                  ProcessPaymentAction::clearFake();
                  SendPaymentReceiptAction::clearFake();
                  UpdateInventoryAction::clearFake();
              }

              #[Test]
              public function successful_checkout_processes_payment_and_sends_receipt(): void
              {
                  // Arrange
                  $order = Order::factory()->create(['total' => 99.99]);
                  $paymentResult = new PaymentResult(successful: true, transactionId: 'txn_123');

                  ProcessPaymentAction::shouldRun()
                      ->with($order, Mockery::type(PaymentMethod::class))
                      ->once()
                      ->andReturn($paymentResult);

                  SendPaymentReceiptAction::shouldRun()
                      ->with($order, $paymentResult)
                      ->once();

                  UpdateInventoryAction::shouldRun()->once();

                  // Act
                  $response = $this->postJson('/api/checkout', [
                      'order_id' => $order->id,
                      'payment_method' => 'card_xxx',
                  ]);

                  // Assert
                  $response->assertOk();
              }

              #[Test]
              public function failed_payment_does_not_send_receipt(): void
              {
                  $order = Order::factory()->create();
                  $failedResult = new PaymentResult(successful: false, error: 'Card declined');

                  ProcessPaymentAction::shouldRun()
                      ->once()
                      ->andReturn($failedResult);

                  // These should NOT be called
                  SendPaymentReceiptAction::shouldNotRun();
                  UpdateInventoryAction::shouldNotRun();

                  $response = $this->postJson('/api/checkout', [
                      'order_id' => $order->id,
                      'payment_method' => 'card_xxx',
                  ]);

                  $response->assertStatus(422);
              }

              #[Test]
              public function partial_mock_for_testing_internal_logic(): void
              {
                  $order = Order::factory()->create();

                  // Only mock the external gateway call, let other logic run
                  ProcessPaymentAction::partialMock()
                      ->shouldReceive('chargeGateway')
                      ->once()
                      ->andReturn(new PaymentResult(successful: true, transactionId: 'txn_456'));

                  $result = ProcessPaymentAction::run($order, new CreditCard('4111...'));

                  $this->assertTrue($result->successful());
                  $this->assertEquals('txn_456', $result->transactionId);
              }

              #[Test]
              public function spy_allows_verification_after_the_fact(): void
              {
                  $order = Order::factory()->create();

                  // Allow the action to run, but spy on it
                  SendPaymentReceiptAction::allowToRun();

                  // Run the full checkout flow
                  ProcessPaymentAction::run($order, new CreditCard('4111...'));

                  // Verify the receipt was sent with correct arguments
                  SendPaymentReceiptAction::spy()
                      ->shouldHaveReceived('handle')
                      ->with(
                          Mockery::on(fn ($arg) => $arg->id === $order->id),
                          Mockery::type(PaymentResult::class)
                      )
                      ->once();
              }
          }
  -
    type: heading
    attrs:
      level: 1
    content:
      -
        type: text
        text: "Comparison with Laravel's Built-in Fakes"
  -
    type: paragraph
    content:
      -
        type: text
        text: "This pattern isn't invented from scratch; it mirrors how Laravel handles faking for its own services."
  -
    type: codeBlock
    attrs:
      language: null
    content:
      -
        type: text
        text: |
          ┌──────────────────────┬────────────────────────────┬──────────────────────────────┐
          │ Feature              │ Bus::fake()                │ Our Action Pattern           │
          ├──────────────────────┼────────────────────────────┼──────────────────────────────┤
          │ Static API           │ Bus::fake()                │ Action::mock()               │
          │ Container Integration│ Swaps binding              │ Swaps via extend()           │
          │ Expectation Chaining │ Bus::assertDispatched()    │ shouldRun()->once()          │
          │ Spy Support          │ Bus::assertDispatchedTimes()│ spy()->shouldHaveReceived() │
          │ Clear/Restore        │ Fresh app instance         │ clearFake()                  │
          └──────────────────────┴────────────────────────────┴──────────────────────────────┘
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Key Similarities'
  -
    type: orderedList
    attrs:
      start: 1
    content:
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Container-based swapping'
              -
                type: text
                text: ': Both approaches replace the real implementation at the container level'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Fluent assertions'
              -
                type: text
                text: ': Both provide chainable expectation APIs'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Spy/mock modes'
              -
                type: text
                text: ': Both support "record everything" and "expect specific calls" modes'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Key Differences'
  -
    type: orderedList
    attrs:
      start: 1
    content:
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: Scope
              -
                type: text
                text: ": Laravel's fakes work at the facade level (all jobs, all events), ours work at the class level (each action independently)"
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: Granularity
              -
                type: text
                text: ': You can fake '
              -
                type: text
                marks:
                  -
                    type: code
                text: ProcessPaymentAction
              -
                type: text
                text: ' while letting '
              -
                type: text
                marks:
                  -
                    type: code
                text: SendReceiptAction
              -
                type: text
                text: ' run for real'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'No global fake'
              -
                type: text
                text: ": There's no "
              -
                type: text
                marks:
                  -
                    type: code
                text: 'Action::fake()'
              -
                type: text
                text: ' that fakes all actions—by design, you explicitly choose what to mock'
  -
    type: heading
    attrs:
      level: 1
    content:
      -
        type: text
        text: 'Alternative Approaches (And Why This One Wins)'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Approach 1: Traditional Mockery Injection'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          $mock = Mockery::mock(ProcessPaymentAction::class);
          $this->app->instance(ProcessPaymentAction::class, $mock);
          $mock->shouldReceive('handle')->once()->andReturn($result);
  -
    type: paragraph
    content:
      -
        type: text
        marks:
          -
            type: bold
        text: Pros
      -
        type: text
        text: ': No base class required, works with any class.'
      -
        type: hardBreak
      -
        type: text
        marks:
          -
            type: bold
        text: Cons
      -
        type: text
        text: ': Three lines per mock, verbose setup, easy to forget container binding.'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Approach 2: Interface-Based Mocking'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          interface ProcessPaymentActionInterface { ... }
          class ProcessPaymentAction implements ProcessPaymentActionInterface { ... }

          // In test:
          $this->mock(ProcessPaymentActionInterface::class)
              ->shouldReceive('handle')
              ->once();
  -
    type: paragraph
    content:
      -
        type: text
        marks:
          -
            type: bold
        text: Pros
      -
        type: text
        text: ": Laravel's "
      -
        type: text
        marks:
          -
            type: code
        text: $this->mock()
      -
        type: text
        text: ' handles binding automatically.'
      -
        type: hardBreak
      -
        type: text
        marks:
          -
            type: bold
        text: Cons
      -
        type: text
        text: ': Requires an interface per action (boilerplate explosion), breaks static '
      -
        type: text
        marks:
          -
            type: code
        text: '::run()'
      -
        type: text
        text: ' API.'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Approach 3: Dependency Injection Only'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Pass actions as constructor dependencies instead of calling them statically:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          class CheckoutController
          {
              public function __construct(
                  private ProcessPaymentAction $processPayment,
                  private SendReceiptAction $sendReceipt
              ) {}
          }
  -
    type: paragraph
    content:
      -
        type: text
        marks:
          -
            type: bold
        text: Pros
      -
        type: text
        text: ': Pure DI, no static methods.'
      -
        type: hardBreak
      -
        type: text
        marks:
          -
            type: bold
        text: Cons
      -
        type: text
        text: ': Every consumer needs all possible actions injected, calling code becomes verbose.'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Why Self-Mocking Wins'
  -
    type: orderedList
    attrs:
      start: 1
    content:
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Zero boilerplate'
              -
                type: text
                text: ': One line per mocked action'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: Self-documenting
              -
                type: text
                text: ': '
              -
                type: text
                marks:
                  -
                    type: code
                text: 'ProcessPaymentAction::shouldRun()'
              -
                type: text
                text: ' reads like a specification'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Consistent API'
              -
                type: text
                text: ': Every action works the same way'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: Laravel-native
              -
                type: text
                text: ': Follows patterns established by the framework itself'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Opt-in mocking'
              -
                type: text
                text: ': Real implementations run by default; you explicitly choose what to fake'
  -
    type: heading
    attrs:
      level: 1
    content:
      -
        type: text
        text: 'Best Practices and Gotchas'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Always Clear Fakes in '
      -
        type: text
        marks:
          -
            type: code
        text: setUp()
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          protected function setUp(): void
          {
              parent::setUp();

              ProcessPaymentAction::clearFake();
              SendReceiptAction::clearFake();
          }
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Or create a test trait that clears all known fakes.'
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Beware of '
      -
        type: text
        marks:
          -
            type: code
        text: 'shouldNotRun() '
      -
        type: text
        text: Timing
  -
    type: paragraph
    content:
      -
        type: text
        text: "Mockery's "
      -
        type: text
        marks:
          -
            type: code
        text: shouldNotReceive()
      -
        type: text
        text: ' exceptions are thrown at '
      -
        type: text
        marks:
          -
            type: code
        text: 'Mockery::close()'
      -
        type: text
        text: ' time (end of test), not when the method is called. This can make debugging confusing. Always check that your '
      -
        type: text
        marks:
          -
            type: italic
        text: '"should not run"'
      -
        type: text
        text: " action actually shouldn't run in your test scenario."
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Use '
      -
        type: text
        marks:
          -
            type: code
        text: because()
      -
        type: text
        text: ' for Better Error Messages'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The base implementation includes '
      -
        type: text
        marks:
          -
            type: code
        text: '->because()'
      -
        type: text
        text: ' calls, but you can add more context:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          SendReceiptAction::shouldRun()
              ->once()
              ->because('A receipt must be sent after successful payment');
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: 'Consider a Trait for Multiple Base Classes'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'If you have multiple base classes (e.g., '
      -
        type: text
        marks:
          -
            type: code
        text: Action
      -
        type: text
        text: ', '
      -
        type: text
        marks:
          -
            type: code
        text: Query
      -
        type: text
        text: ', '
      -
        type: text
        marks:
          -
            type: code
        text: Command
      -
        type: text
        text: '), extract the mocking logic to a trait:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          trait Fakeable
          {
              public static function mock(): MockInterface { ... }
              public static function spy(): MockInterface { ... }
              // ... etc
          }

          abstract class Action
          {
              use Fakeable;
          }

          abstract class Query
          {
              use Fakeable;
          }
  -
    type: heading
    attrs:
      level: 2
    content:
      -
        type: text
        text: "Don't Over-Mock"
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Just because '
      -
        type: text
        marks:
          -
            type: italic
        text: 'you can mock'
      -
        type: text
        text: " every action doesn't mean you "
      -
        type: text
        marks:
          -
            type: italic
        text: should
      -
        type: text
        text: '. Consider:'
  -
    type: bulletList
    content:
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'Mock external dependencies (payment gateways, email services)'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'Let simple internal actions run for real'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'Use partial mocks when you only need to stub one method'
  -
    type: heading
    attrs:
      level: 1
    content:
      -
        type: text
        text: Conclusion
  -
    type: paragraph
    content:
      -
        type: text
        text: "Self-mocking actions bring the elegance of Laravel's built-in faking system to your own code. The pattern leverages three powerful but underused Laravel features:"
  -
    type: orderedList
    attrs:
      start: 1
    content:
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: code
                text: beforeResolving()
              -
                type: text
                text: ' — Hook into every container resolution'
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: code
                text: extend()
              -
                type: text
                text: " — Modify resolved instances before they're returned"
      -
        type: listItem
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Dual-key binding'
              -
                type: text
                text: ' — Store fakes separately from real bindings'
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The result is a testing experience that reads like documentation:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          ProcessPaymentAction::shouldRun()->once()->andReturn($result);
          SendReceiptAction::shouldRun()->with($order)->once();
          RefundAction::shouldNotRun();
  -
    type: paragraph
    content:
      -
        type: text
        text: "This pattern scales beautifully. Whether you have 10 actions or 200, the testing API remains consistent. New team members can read tests and understand what's being verified without deciphering mock setup code."
  -
    type: paragraph
    content:
      -
        type: text
        text: 'The '
      -
        type: text
        marks:
          -
            type: code
        text: beforeResolving
      -
        type: text
        text: " hook is one of Laravel's hidden gems. Now that you've seen it in action, you'll find other creative uses: lazy service decoration, automatic logging, feature flags at the resolution level."
  -
    type: paragraph
    content:
      -
        type: text
        text: 'Build the base class once, and every action you create from now on comes with first-class testing support built in.'
  -
    type: heading
    attrs:
      level: 1
    content:
      -
        type: text
        text: 'Complete Implementation'
  -
    type: paragraph
    content:
      -
        type: text
        text: "For reference, here's the complete base "
      -
        type: text
        marks:
          -
            type: code
        text: Action
      -
        type: text
        text: ' class:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |
          <?php

          namespace App\Actions;

          use Mockery;
          use Mockery\MockInterface;

          abstract class Action
          {
              // region Container

              public static function make(): static
              {
                  return app(static::class);
              }

              public static function run(mixed ...$arguments): mixed
              {
                  return static::make()->handle(...$arguments);
              }

              // endregion

              // region Mocking

              public static function mock(): MockInterface
              {
                  if (static::isFake()) {
                      return static::getFakeResolvedInstance();
                  }

                  $mock = Mockery::mock(static::class);
                  $mock->shouldAllowMockingProtectedMethods();

                  return static::setFakeResolvedInstance($mock);
              }

              public static function spy(): MockInterface
              {
                  if (static::isFake()) {
                      return static::getFakeResolvedInstance();
                  }

                  return static::setFakeResolvedInstance(Mockery::spy(static::class));
              }

              public static function partialMock(): MockInterface
              {
                  return static::mock()->makePartial();
              }

              public static function shouldRun(): Mockery\Expectation
              {
                  return static::mock()
                      ->shouldReceive('handle')
                      ->because(class_basename(static::class) . ' should run but did not.');
              }

              public static function shouldNotRun(): Mockery\Expectation
              {
                  return static::mock()
                      ->shouldNotReceive('handle')
                      ->because(class_basename(static::class) . ' should not run but it did.');
              }

              public static function allowToRun(): Mockery\Expectation
              {
                  return static::spy()->allows('handle');
              }

              public static function isFake(): bool
              {
                  return app()->isShared(static::getFakeResolvedInstanceKey());
              }

              public static function clearFake(): void
              {
                  app()->forgetInstance(static::getFakeResolvedInstanceKey());
              }

              protected static function setFakeResolvedInstance(MockInterface $fake): MockInterface
              {
                  return app()->instance(static::getFakeResolvedInstanceKey(), $fake);
              }

              protected static function getFakeResolvedInstance(): ?MockInterface
              {
                  return app(static::getFakeResolvedInstanceKey());
              }

              protected static function getFakeResolvedInstanceKey(): string
              {
                  return 'Fake:' . static::class;
              }

              // endregion
          }
  -
    type: horizontalRule
  -
    type: paragraph
    content:
      -
        type: text
        marks:
          -
            type: italic
        text: 'This pattern is inspired by the actual implementation used in production at '
      -
        type: text
        marks:
          -
            type: link
            attrs:
              href: 'https://tarfin.com/'
              rel: 'noopener nofollow'
              target: _blank
              title: null
          -
            type: italic
        text: Tarfin
      -
        type: text
        marks:
          -
            type: italic
        text: ", Europe's leading fintech platform for farmer agri-input financing, processing thousands of farmer transactions with complex state machine workflows."
---
