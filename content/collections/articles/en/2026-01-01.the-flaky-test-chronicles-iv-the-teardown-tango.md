---
id: cb6753c2-e359-49bc-832a-51c34c92696d
blueprint: articles
title: 'The Flaky Test Chronicles IV: The Teardown Tango'
subtitle: 'Mastering tearDown, Fakes, and Assertions'
updated_by: b8f3533e-0fcf-42b9-a3d8-c8691deaf917
updated_at: 1767302947
display_date: '2026-01-01'
og_generator_image: the-flaky-test-chronicles-iv-the-teardown-tango.jpg
show_toc: true
toc_levels:
  - 1
content:
  -
    type: blockquote
    content:
      -
        type: paragraph
        attrs:
          textAlign: left
        content:
          -
            type: text
            text: 'One line in '
          -
            type: text
            marks:
              -
                type: code
            text: tearDown()
          -
            type: text
            text: '. Wrong order. 200 tests fail. Nobody knows why.'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'The test suite passed for three months. Then someone added a file upload test. Suddenly, 200 tests started failing randomly. The culprit? One line in '
      -
        type: text
        marks:
          -
            type: code
        text: tearDown()
      -
        type: text
        text: ' - in the wrong order.'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'This part covers the mechanics: '
      -
        type: text
        marks:
          -
            type: code
        text: tearDown()
      -
        type: text
        text: ' ordering, file cleanup traps, observable event side effects, and the assertion patterns that prevent false positives.'
  -
    type: horizontalRule
  -
    type: heading
    attrs:
      textAlign: left
      level: 1
    content:
      -
        type: text
        text: 'The Order of Destruction'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'The '
      -
        type: text
        marks:
          -
            type: code
        text: tearDown()
      -
        type: text
        text: ' method seems simple. Clean up after your test. What could go wrong?'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'Everything. Everything can go wrong.'
  -
    type: heading
    attrs:
      textAlign: left
      level: 2
    content:
      -
        type: text
        text: 'The Golden Rule'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'Custom cleanup BEFORE '
      -
        type: text
        marks:
          -
            type: code
        text: 'parent::tearDown()'
      -
        type: text
        text: '. Always.'
  -
    type: set
    attrs:
      id: mjukv365
      values:
        type: sidenote
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'Call '
              -
                type: text
                marks:
                  -
                    type: code
                text: 'parent::tearDown()'
              -
                type: text
                text: " last. Unless you enjoy debugging why your cleanup code can't access things that no longer exist."
        style: tip
        position: right
  -
    type: codeBlock
    attrs:
      language: null
    content:
      -
        type: text
        text: |-
          ```php
          protected function tearDown(): void
          {
              // 1. Your custom cleanup first
              $this->resetPaymentGateway();
              $this->clearCustomCache();

              // 2. Parent tearDown last
              parent::tearDown();
          }
          ```
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        marks:
          -
            type: bold
        text: 'Why This Order Matters:'
  -
    type: bulletList
    content:
      -
        type: listItem
        content:
          -
            type: paragraph
            attrs:
              textAlign: left
            content:
              -
                type: text
                marks:
                  -
                    type: code
                text: 'parent::tearDown()'
              -
                type: text
                text: ' may clear resources your cleanup needs'
      -
        type: listItem
        content:
          -
            type: paragraph
            attrs:
              textAlign: left
            content:
              -
                type: text
                text: 'Mockery is closed in parent '
              -
                type: text
                marks:
                  -
                    type: code
                text: tearDown
      -
        type: listItem
        content:
          -
            type: paragraph
            attrs:
              textAlign: left
            content:
              -
                type: text
                text: 'Database transactions are rolled back in parent '
              -
                type: text
                marks:
                  -
                    type: code
                text: tearDown
  -
    type: heading
    attrs:
      textAlign: left
      level: 2
    content:
      -
        type: text
        text: 'Universal vs Targeted Cleanup'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'Not all cleanup belongs in base '
      -
        type: text
        marks:
          -
            type: code
        text: TestCase
      -
        type: text
        text: '. The key question: does '
      -
        type: text
        marks:
          -
            type: bold
        text: every
      -
        type: text
        text: ' test need this cleanup?'
  -
    type: set
    attrs:
      id: mjcyx61u
      values:
        type: sidenote
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: '10,000 tests, 5 need payment gateway reset. Centralize = 9,995 unnecessary service resets per run.'
        style: warning
        position: right
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        marks:
          -
            type: bold
        text: 'Universal cleanup (base '
      -
        type: text
        marks:
          -
            type: code
        text: TestCase
      -
        type: text
        marks:
          -
            type: bold
        text: '):'
  -
    type: bulletList
    content:
      -
        type: listItem
        content:
          -
            type: paragraph
            attrs:
              textAlign: left
            content:
              -
                type: text
                text: 'Config/locale resets that affect all tests'
      -
        type: listItem
        content:
          -
            type: paragraph
            attrs:
              textAlign: left
            content:
              -
                type: text
                text: 'Global state that leaks between tests'
      -
        type: listItem
        content:
          -
            type: paragraph
            attrs:
              textAlign: left
            content:
              -
                type: text
                text: 'Framework-level cleanup (Mockery, transactions)'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        marks:
          -
            type: bold
        text: 'Targeted cleanup (opt-in traits):'
  -
    type: bulletList
    content:
      -
        type: listItem
        content:
          -
            type: paragraph
            attrs:
              textAlign: left
            content:
              -
                type: text
                text: 'Payment gateway reset (only tests that mock external services)'
      -
        type: listItem
        content:
          -
            type: paragraph
            attrs:
              textAlign: left
            content:
              -
                type: text
                text: 'External service cleanup (only integration tests)'
      -
        type: listItem
        content:
          -
            type: paragraph
            attrs:
              textAlign: left
            content:
              -
                type: text
                text: 'File system cleanup (only tests that write files)'
  -
    type: heading
    attrs:
      textAlign: left
      level: 2
    content:
      -
        type: text
        text: 'The Opt-in Trait Pattern'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'Laravel automatically discovers '
      -
        type: text
        marks:
          -
            type: code
        text: setUpXXX()
      -
        type: text
        text: ' and '
      -
        type: text
        marks:
          -
            type: code
        text: tearDownXXX()
      -
        type: text
        text: ' methods in traits. Use this for targeted cleanup:'
  -
    type: set
    attrs:
      id: mjulz1va
      values:
        type: sidenote
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'The trait docblock is your documentation. Future developers will know exactly when to use it.'
        style: tip
        position: right
  -
    type: codeBlock
    attrs:
      language: null
    content:
      -
        type: text
        text: |-
          ```php
          /**
           * Use this trait in tests that interact with the payment gateway
           * and need to reset its singleton state between tests.
           */
          trait ResetsPaymentGateway
          {
              protected function tearDownResetsPaymentGateway(): void
              {
                  app()->forgetInstance(PaymentGateway::class);
                  app()->forgetInstance(PaymentProcessor::class);
              }
          }
          ```
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'Multiple test classes need this cleanup - they share the trait instead of duplicating the logic:'
  -
    type: codeBlock
    attrs:
      language: null
    content:
      -
        type: text
        text: |-
          ```php
          class PaymentGatewayTest extends TestCase
          {
              use ResetsPaymentGateway;  // Opt-in: this test uses payment services

              #[Test]
              public function it_uses_correct_provider(): void
              {
                  $this->mock(PaymentGateway::class)
                      ->shouldReceive('process')
                      ->andReturn(true);
                  // ...
              }
          }
          ```
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        marks:
          -
            type: bold
        text: 'Benefits:'
  -
    type: bulletList
    content:
      -
        type: listItem
        content:
          -
            type: paragraph
            attrs:
              textAlign: left
            content:
              -
                type: text
                text: "Zero overhead for tests that don't need it"
      -
        type: listItem
        content:
          -
            type: paragraph
            attrs:
              textAlign: left
            content:
              -
                type: text
                text: 'Self-documenting: trait name and docblock explain the '
              -
                type: text
                marks:
                  -
                    type: italic
                text: “why”
      -
        type: listItem
        content:
          -
            type: paragraph
            attrs:
              textAlign: left
            content:
              -
                type: text
                text: 'Explicit dependency: you see which tests have special needs'
  -
    type: horizontalRule
  -
    type: heading
    attrs:
      textAlign: left
      level: 1
    content:
      -
        type: text
        text: 'The Shared Resource Trap'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'Two tests. Same file path. One writes, the other overwrites. Sometimes Test '
      -
        type: text
        marks:
          -
            type: code
        text: A
      -
        type: text
        text: ' finishes first. Sometimes Test '
      -
        type: text
        marks:
          -
            type: code
        text: B
      -
        type: text
        text: '. The result? Flaky.'
  -
    type: set
    attrs:
      id: fileclean01
      values:
        type: sidenote
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'This applies to any shared resource: files, cache keys, database rows, external service state.'
        style: note
        position: right
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |-
          ```php
          // Test A
          public function it_exports_orders(): void
          {
              $this->exportService->export($orders, '/tmp/export.csv');
              $this->assertFileExists('/tmp/export.csv');
          }

          // Test B - runs in parallel
          public function it_exports_invoices(): void
          {
              $this->exportService->export($invoices, '/tmp/export.csv');  // Same path!
              $this->assertStringContainsString('Invoice', file_get_contents('/tmp/export.csv'));
          }
          // One test reads the other's file. Flaky.
          ```
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'The fix is isolation. Each test needs its own resource.'
  -
    type: heading
    attrs:
      textAlign: left
      level: 2
    content:
      -
        type: text
        text: 'The Easy Way: Storage::fake()'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'For file operations, '
      -
        type: text
        marks:
          -
            type: code
        text: 'Storage::fake()'
      -
        type: text
        text: ' creates a temporary disk that gets cleared on each call:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |-
          ```php
          public function it_exports_orders(): void
          {
              Storage::fake('local');

              $this->exportService->export($orders, 'export.csv');

              Storage::disk('local')->assertExists('export.csv');
          }
          ```
  -
    type: heading
    attrs:
      textAlign: left
      level: 2
    content:
      -
        type: text
        text: 'When You Need Real Paths'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: "Sometimes you can't use fake disks - absolute paths, actual filesystem behavior, or third-party packages. Then make paths unique per test:"
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |-
          ```php
          public function it_exports_orders(): void
          {
              $path = storage_path('exports/test-' . $this->name() . '-' . uniqid() . '.csv');

              $this->exportService->export($orders, $path);

              $this->assertFileExists($path);
              @unlink($path);  // Clean up
          }
          ```
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'Or use a trait to handle the pattern:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |-
          ```php
          trait CreatesUniqueTestFiles
          {
              protected array $testFiles = [];

              protected function testPath(string $filename): string
              {
                  $path = storage_path('test-files/' . $this->name() . '-' . uniqid() . '-' . $filename);
                  $this->testFiles[] = $path;
                  return $path;
              }

              protected function tearDownCreatesUniqueTestFiles(): void
              {
                  foreach ($this->testFiles as $path) {
                      @unlink($path);
                  }
              }
          }
          ```
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'The pattern extends beyond files. Cache keys, queue names, temporary database records - anything shared between parallel tests needs isolation.'
  -
    type: horizontalRule
  -
    type: heading
    attrs:
      textAlign: left
      level: 1
    content:
      -
        type: text
        text: 'The Cache vs Mock Race'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'Test '
      -
        type: text
        marks:
          -
            type: code
        text: A
      -
        type: text
        text: ' caches a config value. Test '
      -
        type: text
        marks:
          -
            type: code
        text: B
      -
        type: text
        text: ' mocks the same config. The cache wins. Test B fails - but only when it runs after Test '
      -
        type: text
        marks:
          -
            type: code
        text: A
      -
        type: text
        text: .
  -
    type: set
    attrs:
      id: mjcz6q9x
      values:
        type: sidenote
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'Run tests in isolation? Pass. Run full suite? Fail. Classic flaky pattern.'
        style: danger
        position: right
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |-
          ```php
          // Test A - runs first, caches the value
          public function it_checks_feature_flag(): void
          {
              $enabled = config('feature.notifications_enabled');  // Cached!
              // ...
          }

          // Test B - runs second, tries to mock
          public function it_disables_notifications(): void
          {
              Config::shouldReceive('get')
                  ->with('feature.notifications_enabled')
                  ->andReturn(false);

              // Mock never triggers - cached value wins
              // Test fails randomly depending on execution order
          }
          ```
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'The fix: clear the cache before mocking.'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |-
          ```php
          public function it_disables_notifications(): void
          {
              // Clear before mock
              cache()->forget('feature.notifications_enabled');

              Config::shouldReceive('get')
                  ->with('feature.notifications_enabled')
                  ->andReturn(false);

              // Now the mock works regardless of test order
          }
          ```
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'This applies to any cached value you want to mock: config, service responses, computed results. If it might be cached, clear it first.'
  -
    type: horizontalRule
  -
    type: heading
    attrs:
      textAlign: left
      level: 1
    content:
      -
        type: text
        text: 'Observable Events: The Silent Side Effects'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: "Model observers can wreak havoc on tests. But the solution isn't to blindly suppress all observers. The real task is identifying which ones introduce "
      -
        type: text
        marks:
          -
            type: bold
        text: non-determinism
      -
        type: text
        text: .
  -
    type: heading
    attrs:
      textAlign: left
      level: 2
    content:
      -
        type: text
        text: 'The Flaky Risk Spectrum'
  -
    type: set
    attrs:
      id: mjczbsly
      values:
        type: sidenote
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'The question to ask: “'
              -
                type: text
                marks:
                  -
                    type: italic
                text: 'Does this observer touch the outside world or shared state?”'
        style: info
        position: right
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'Not all observers cause flaky tests. The risk depends on what they do:'
  -
    type: bulletList
    content:
      -
        type: listItem
        content:
          -
            type: paragraph
            attrs:
              textAlign: left
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'High risk'
              -
                type: text
                text: ': External API calls, notifications, queue dispatching'
      -
        type: listItem
        content:
          -
            type: paragraph
            attrs:
              textAlign: left
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Medium risk'
              -
                type: text
                text: ': Database updates to related models, cache mutations (especially in parallel tests)'
      -
        type: listItem
        content:
          -
            type: paragraph
            attrs:
              textAlign: left
            content:
              -
                type: text
                marks:
                  -
                    type: bold
                text: 'Low/No risk'
              -
                type: text
                text: ': UUID generation, slug creation, simple timestamps'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'A typical problematic observer:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |-
          ```php
          class OrderObserver
          {
              public function created(Order $order): void
              {
                  // High risk: sends HTTP request
                  Http::post('https://analytics.example.com/track', [...]);

                  // High risk: dispatches notification
                  $order->user->notify(new OrderCreated($order));

                  // Medium risk: mutates related model
                  $order->user->increment('order_count');
              }
          }
          ```
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'Compare this to a safe observer:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |-
          ```php
          class OrderObserver
          {
              public function creating(Order $order): void
              {
                  // No risk: deterministic, no external deps
                  $order->uuid ??= Str::uuid();
                  $order->reference ??= $this->generateReference();
              }
          }
          ```
  -
    type: heading
    attrs:
      textAlign: left
      level: 2
    content:
      -
        type: text
        text: 'Laravel Native: All-or-Nothing Control'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'For simple cases, Laravel provides built-in methods to silence all model events:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |-
          ```php
          // Silence all events within a closure
          $order = Order::withoutEvents(function () {
              return Order::factory()->create();
          });

          // Or use quiet methods for single operations
          $order->saveQuietly();
          $order->deleteQuietly();
          ```
  -
    type: set
    attrs:
      id: obs-native-note
      values:
        type: sidenote
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'The downside: this also silences safe observers like UUID generation. Sometimes you need surgical precision.'
        style: warning
        position: right
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'This works when you want to silence everything. But what if your '
      -
        type: text
        marks:
          -
            type: code
        text: creating
      -
        type: text
        text: ' event sets a UUID (safe) while your '
      -
        type: text
        marks:
          -
            type: code
        text: created
      -
        type: text
        text: ' event sends a notification (risky)?'
  -
    type: heading
    attrs:
      textAlign: left
      level: 2
    content:
      -
        type: text
        text: 'Surgical Control with ignorable-observers'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'The '
      -
        type: text
        marks:
          -
            type: link
            attrs:
              href: 'https://github.com/zachflower/ignorable-observers'
              rel: null
              target: _blank
              title: null
        text: ignorable-observers
      -
        type: text
        text: ' package lets you suppress specific events while keeping others active:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |-
          ```php
          // In setUp(): suppress only the risky events
          Order::ignoreObservableEvents(['created', 'updated']);
          // 'creating' still runs - UUID generation works

          User::ignoreObservableEvents(['saved']);
          // Notifications won't fire, but validation observers do
          ```
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'When you actually need to test observer behavior, temporarily re-enable:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |-
          ```php
          #[Test]
          public function it_sends_notification_on_order_creation(): void
          {
              Notification::fake();
              Order::unignoreObservableEvents(['created']);

              $order = Order::factory()->create();

              Notification::assertSentTo($order->user, OrderCreated::class);

              Order::ignoreObservableEvents(['created']);  // Clean up
          }
          ```
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'This pattern gives you the best of both worlds: deterministic tests by default, with the ability to test observer behavior when needed.'
  -
    type: horizontalRule
  -
    type: heading
    attrs:
      textAlign: left
      level: 1
    content:
      -
        type: text
        text: 'HTTP, Events, and Queue Fakes'
  -
    type: heading
    attrs:
      textAlign: left
      level: 2
    content:
      -
        type: text
        marks:
          -
            type: code
        text: 'Http::fake()'
      -
        type: text
        text: ' Precedence'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'Laravel matches HTTP fakes in array order. The first matching pattern wins. Put wildcards last, or they swallow everything.'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        marks:
          -
            type: bold
        text: 'Before (Broken):'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |-
          ```php
          Http::fake([
              'api.example.com/*' => Http::response(['status' => 'ok']),      // Wildcard first
              'api.example.com/users' => Http::response(['users' => [...]]),  // Never reached!
          ]);

          // GET api.example.com/users returns {'status': 'ok'} - wrong response
          // The wildcard matched first, specific route never checked
          ```
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        marks:
          -
            type: bold
        text: 'After (Correct):'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |-
          ```php
          Http::fake([
              'api.example.com/users' => Http::response(['users' => [...]]),  // Specific first
              'api.example.com/*' => Http::response(['status' => 'ok']),      // Wildcard catches the rest
          ]);

          // GET api.example.com/users returns {'users': [...]} - correct
          // GET api.example.com/orders returns {'status': 'ok'} - wildcard fallback
          ```
  -
    type: set
    attrs:
      id: mjczetws
      values:
        type: sidenote
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'Avoid '
              -
                type: text
                marks:
                  -
                    type: code
                text: 'Http::sequence()'
              -
                type: text
                text: ' in parallel tests. It returns responses in order, but parallel tests consume them unpredictably. Test A might get the response meant for Test B.'
        style: danger
        position: right
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'Think of it like route definitions in Laravel: more specific routes go before catch-all routes. Same principle.'
  -
    type: heading
    attrs:
      textAlign: left
      level: 2
    content:
      -
        type: text
        text: 'Queue/Bus Fakes'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: "You faked the bus. The job won't run. Its internal mocks are useless."
  -
    type: codeBlock
    attrs:
      language: null
    content:
      -
        type: text
        text: |-
          ```php
          Bus::fake();

          // Job won't execute - no need to mock its internals
          ProcessOrder::withChain([
              new SendConfirmation(),
              new UpdateInventory()
          ])->dispatch($order);

          // Assert on structure, not execution
          Bus::assertDispatched(ProcessOrder::class, fn ($job) =>
              $job->chained[0] instanceof SendConfirmation
          );
          ```
  -
    type: heading
    attrs:
      textAlign: left
      level: 2
    content:
      -
        type: text
        text: 'Partial Fakes'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: "Sometimes you want some jobs to run, sometimes you don't. Be explicit."
  -
    type: codeBlock
    attrs:
      language: null
    content:
      -
        type: text
        text: |-
          ```php
          // Only fake SpecificJob - let others run
          Bus::fake([SpecificJob::class]);
          ```
  -
    type: heading
    attrs:
      textAlign: left
      level: 2
    content:
      -
        type: text
        text: 'Event Fakes'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'Events firing events can get messy. Fake only what you need.'
  -
    type: codeBlock
    attrs:
      language: null
    content:
      -
        type: text
        text: |-
          ```php
          // Only fake OrderUpdated - let nested events fire
          Event::fake([OrderUpdated::class]);

          $order->update(['status' => 'completed']);

          Event::assertDispatched(OrderUpdated::class);
          ```
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'Or use '
      -
        type: text
        marks:
          -
            type: code
        text: fakeFor
      -
        type: text
        text: ' for scoped faking:'
  -
    type: codeBlock
    attrs:
      language: null
    content:
      -
        type: text
        text: |-
          ```php
          Event::fakeFor(function () use ($order) {
              $order->update(['status' => 'completed']);
              Event::assertDispatched(OrderUpdated::class);
          });
          // Events are real again here
          ```
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'For centralizing fakes in your base TestCase and trait-based faking strategies, see '
      -
        type: text
        marks:
          -
            type: link
            attrs:
              href: /articles/the-flaky-test-chronicles-v-the-abstraction-avalanche
              rel: null
              target: null
              title: null
        text: 'Part 5: The Abstraction Avalanche'
      -
        type: text
        text: .
  -
    type: heading
    attrs:
      textAlign: left
      level: 2
    content:
      -
        type: text
        text: 'Timing Matters'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'Fake '
      -
        type: text
        marks:
          -
            type: bold
        text: BEFORE
      -
        type: text
        text: ' you trigger. Always.'
  -
    type: codeBlock
    attrs:
      language: null
    content:
      -
        type: text
        text: |-
          ```php
          // CORRECT ORDER
          Notification::fake();
          Mail::fake();

          $order = Order::factory()->create();  // afterCreating hooks won't send real notifications
          ```
  -
    type: horizontalRule
  -
    type: heading
    attrs:
      textAlign: left
      level: 1
    content:
      -
        type: text
        text: 'Assertion Patterns'
  -
    type: heading
    attrs:
      textAlign: left
      level: 2
    content:
      -
        type: text
        text: 'Boolean Properties'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        marks:
          -
            type: code
        text: assertTrue()
      -
        type: text
        text: ' accepts any '
      -
        type: text
        marks:
          -
            type: italic
        text: '“truthy” '
      -
        type: text
        text: 'value, not just '
      -
        type: text
        marks:
          -
            type: code
        text: 'true'
      -
        type: text
        text: '. This can mask type bugs:'
  -
    type: codeBlock
    attrs:
      language: php
    content:
      -
        type: text
        text: |-
          ```php
          // Model WITHOUT boolean cast
          class User extends Model
          {
              // protected $casts = ['is_active' => 'boolean']; // Missing!
          }

          // Test passes - you think everything is fine
          $user = User::factory()->create(['is_active' => true]);
          $this->assertTrue($user->fresh()->is_active);  // ✓ passes

          // But your API returns: {"id": 1, "is_active": 1}
          // Frontend JavaScript breaks: if (user.is_active === true) // never executes!

          // assertSame catches the missing cast:
          $this->assertSame(true, $user->fresh()->is_active);  // ✗ fails
          ```
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'Add the '
      -
        type: text
        marks:
          -
            type: code
        text: boolean
      -
        type: text
        text: ' cast to your model, and '
      -
        type: text
        marks:
          -
            type: code
        text: assertSame
      -
        type: text
        text: ' passes. If not, you catch the bug before production.'
  -
    type: heading
    attrs:
      textAlign: left
      level: 2
    content:
      -
        type: text
        text: 'Money Objects'
  -
    type: set
    attrs:
      id: money-precision-note
      values:
        type: sidenote
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: 'The '
              -
                type: text
                marks:
                  -
                    type: link
                    attrs:
                      href: 'https://github.com/brick/money'
                      rel: null
                      target: _blank
                      title: null
                text: brick/money
              -
                type: text
                text: ' package handles precision, rounding, and currency conversion correctly.'
        style: tip
        position: right
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'Floats are liars. '
      -
        type: text
        marks:
          -
            type: code
        text: '0.10 !== 0.1'
      -
        type: text
        text: ' in floating point land. I wrote about this in '
      -
        type: text
        marks:
          -
            type: link
            attrs:
              href: /articles/financial-precision-in-agriculture-fintech
              rel: null
              target: null
              title: null
        text: 'Financial Precision in Agriculture Fintech'
      -
        type: text
        text: '. The short version: use Money objects with sufficient precision, and store them that way too.'
  -
    type: codeBlock
    attrs:
      language: null
    content:
      -
        type: text
        text: |-
          ```php
          // WRONG: Float comparison nightmares
          $this->assertEquals($expected, $actual);

          // CORRECT: Use Money's comparison
          $this->assertTrue($expectedMoney->isEqualTo($actualMoney));
          ```
  -
    type: heading
    attrs:
      textAlign: left
      level: 2
    content:
      -
        type: text
        text: 'Exception Assertions'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        marks:
          -
            type: bold
        text: 'Pattern 1: Use '
      -
        type: text
        marks:
          -
            type: code
        text: $this->fail()
      -
        type: text
        marks:
          -
            type: bold
        text: ' for '
      -
        type: text
        text: try/catch
  -
    type: codeBlock
    attrs:
      language: null
    content:
      -
        type: text
        text: |-
          ```php
          public function it_throws_validation_exception(): void
          {
              try {
                  OrderValidator::validate($order);

                  $this->fail('ValidationException was not thrown');
              } catch (ValidationException $e) {
                  $this->assertEquals('expected', $e->getMessage());
              }
          }
          ```
  -
    type: set
    attrs:
      id: mjczog3k
      values:
        type: sidenote
        content:
          -
            type: paragraph
            content:
              -
                type: text
                marks:
                  -
                    type: code
                text: expectException()
              -
                type: text
                text: ' is cleaner. The '
              -
                type: text
                marks:
                  -
                    type: code
                text: try/catch
              -
                type: text
                text: " pattern has its place, but it's not your first choice."
        style: tip
        position: right
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        marks:
          -
            type: bold
        text: 'Pattern 2: Use '
      -
        type: text
        marks:
          -
            type: code
        text: expectException()
      -
        type: text
        marks:
          -
            type: bold
        text: ' (Preferred)'
  -
    type: codeBlock
    attrs:
      language: null
    content:
      -
        type: text
        text: |-
          ```php
          public function it_throws_validation_exception(): void
          {
              $this->expectException(ValidationException::class);
              $this->expectExceptionMessage('expected');

              OrderValidator::validate($order);
          }
          ```
  -
    type: horizontalRule
  -
    type: heading
    attrs:
      textAlign: left
      level: 1
    content:
      -
        type: text
        text: 'Risky Test Prevention'
  -
    type: set
    attrs:
      id: mjczqme3
      values:
        type: sidenote
        content:
          -
            type: paragraph
            content:
              -
                type: text
                text: "A test without assertions is not a test. It's a lie you tell CI."
        style: warning
        position: right
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'PHPUnit marks tests as '
      -
        type: text
        marks:
          -
            type: code
        text: risky
      -
        type: text
        text: ' when they have no assertions. This often indicates a problem with the test.'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        marks:
          -
            type: bold
        text: 'Before (Risky - no assertion if exception not thrown):'
  -
    type: codeBlock
    attrs:
      language: null
    content:
      -
        type: text
        text: |-
          ```php
          #[Test]
          public function it_throws_validation_exception(): void
          {
              try {
                  OrderValidator::validate($order);
              } catch (ValidationException $e) {
                  $this->assertEquals('expected', $e->getMessage());
              }
              // If no exception is thrown, test passes with no assertions = risky!
          }
          ```
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        marks:
          -
            type: bold
        text: 'After (Explicit failure if no exception):'
  -
    type: codeBlock
    attrs:
      language: null
    content:
      -
        type: text
        text: |-
          ```php
          #[Test]
          public function it_throws_validation_exception(): void
          {
              try {
                  OrderValidator::validate($order);

                  $this->fail('ValidationException was not thrown');
              } catch (ValidationException $e) {
                  $this->assertEquals('expected', $e->getMessage());
              }
          }
          ```
  -
    type: horizontalRule
  -
    type: heading
    attrs:
      textAlign: left
      level: 1
    content:
      -
        type: text
        text: "What's Next"
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'Missed the previous part? '
      -
        type: text
        marks:
          -
            type: link
            attrs:
              href: /articles/the-flaky-test-chronicles-iii-the-determinism-principle
              rel: null
              target: null
              title: null
        text: 'Part 3: The Determinism Principle'
      -
        type: text
        text: ' covers time control, random values, and DataProvider timing issues.'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        marks:
          -
            type: link
            attrs:
              href: /articles/the-flaky-test-chronicles-v-the-abstraction-avalanche
              rel: null
              target: null
              title: null
        text: 'Part 5: The Abstraction Avalanche'
      -
        type: text
        text: ' covers the test infrastructure itself:'
  -
    type: bulletList
    content:
      -
        type: listItem
        content:
          -
            type: paragraph
            attrs:
              textAlign: left
            content:
              -
                type: text
                text: 'The base TestCase architecture'
      -
        type: listItem
        content:
          -
            type: paragraph
            attrs:
              textAlign: left
            content:
              -
                type: text
                text: 'Trait organization and naming conventions'
      -
        type: listItem
        content:
          -
            type: paragraph
            attrs:
              textAlign: left
            content:
              -
                type: text
                text: 'Authentication helpers and Passport patterns'
      -
        type: listItem
        content:
          -
            type: paragraph
            attrs:
              textAlign: left
            content:
              -
                type: text
                text: 'Service faking strategy'
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        text: 'See you there.'
  -
    type: horizontalRule
  -
    type: paragraph
    attrs:
      textAlign: left
    content:
      -
        type: text
        marks:
          -
            type: italic
        text: 'The Flaky Test Chronicles is a series documenting what we learned from 300+ commits of test suite cleanup. Remember: parent::tearDown() goes last. Your sanity depends on it.'
---
